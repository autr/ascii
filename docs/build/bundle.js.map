{"version":3,"file":"bundle.js","sources":["../../node_modules/.pnpm/svelte@3.44.2/node_modules/svelte/internal/index.mjs","../../node_modules/.pnpm/wheel@1.0.0/node_modules/wheel/index.js","../../node_modules/.pnpm/bezier-easing@2.1.0/node_modules/bezier-easing/src/index.js","../../node_modules/.pnpm/amator@1.1.0/node_modules/amator/index.js","../../node_modules/.pnpm/ngraph.events@1.2.1/node_modules/ngraph.events/index.js","../../node_modules/.pnpm/panzoom@9.4.2/node_modules/panzoom/lib/kinetic.js","../../node_modules/.pnpm/panzoom@9.4.2/node_modules/panzoom/lib/createTextSelectionInterceptor.js","../../node_modules/.pnpm/panzoom@9.4.2/node_modules/panzoom/lib/transform.js","../../node_modules/.pnpm/panzoom@9.4.2/node_modules/panzoom/lib/svgController.js","../../node_modules/.pnpm/panzoom@9.4.2/node_modules/panzoom/lib/domController.js","../../node_modules/.pnpm/panzoom@9.4.2/node_modules/panzoom/index.js","../../src/Panel.svelte","../../src/Defs.js","../../src/Chars.js","../../node_modules/.pnpm/svelte@3.44.2/node_modules/svelte/store/index.mjs","../../src/Store.js","../../node_modules/.pnpm/diff@5.0.0/node_modules/diff/lib/index.mjs","../../src/Keys.js","../../src/Keyboard.svelte","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.2' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","/**\n * This module used to unify mouse wheel behavior between different browsers in 2014\n * Now it's just a wrapper around addEventListener('wheel');\n *\n * Usage:\n *  var addWheelListener = require('wheel').addWheelListener;\n *  var removeWheelListener = require('wheel').removeWheelListener;\n *  addWheelListener(domElement, function (e) {\n *    // mouse wheel event\n *  });\n *  removeWheelListener(domElement, function);\n */\n\nmodule.exports = addWheelListener;\n\n// But also expose \"advanced\" api with unsubscribe:\nmodule.exports.addWheelListener = addWheelListener;\nmodule.exports.removeWheelListener = removeWheelListener;\n\n\nfunction addWheelListener(element, listener, useCapture) {\n  element.addEventListener('wheel', listener, useCapture);\n}\n\nfunction removeWheelListener( element, listener, useCapture ) {\n  element.removeEventListener('wheel', listener, useCapture);\n}","/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nfunction LinearEasing (x) {\n  return x;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n","var BezierEasing = require('bezier-easing')\n\n// Predefined set of animations. Similar to CSS easing functions\nvar animations = {\n  ease:  BezierEasing(0.25, 0.1, 0.25, 1),\n  easeIn: BezierEasing(0.42, 0, 1, 1),\n  easeOut: BezierEasing(0, 0, 0.58, 1),\n  easeInOut: BezierEasing(0.42, 0, 0.58, 1),\n  linear: BezierEasing(0, 0, 1, 1)\n}\n\n\nmodule.exports = animate;\nmodule.exports.makeAggregateRaf = makeAggregateRaf;\nmodule.exports.sharedScheduler = makeAggregateRaf();\n\n\nfunction animate(source, target, options) {\n  var start = Object.create(null)\n  var diff = Object.create(null)\n  options = options || {}\n  // We let clients specify their own easing function\n  var easing = (typeof options.easing === 'function') ? options.easing : animations[options.easing]\n\n  // if nothing is specified, default to ease (similar to CSS animations)\n  if (!easing) {\n    if (options.easing) {\n      console.warn('Unknown easing function in amator: ' + options.easing);\n    }\n    easing = animations.ease\n  }\n\n  var step = typeof options.step === 'function' ? options.step : noop\n  var done = typeof options.done === 'function' ? options.done : noop\n\n  var scheduler = getScheduler(options.scheduler)\n\n  var keys = Object.keys(target)\n  keys.forEach(function(key) {\n    start[key] = source[key]\n    diff[key] = target[key] - source[key]\n  })\n\n  var durationInMs = typeof options.duration === 'number' ? options.duration : 400\n  var durationInFrames = Math.max(1, durationInMs * 0.06) // 0.06 because 60 frames pers 1,000 ms\n  var previousAnimationId\n  var frame = 0\n\n  previousAnimationId = scheduler.next(loop)\n\n  return {\n    cancel: cancel\n  }\n\n  function cancel() {\n    scheduler.cancel(previousAnimationId)\n    previousAnimationId = 0\n  }\n\n  function loop() {\n    var t = easing(frame/durationInFrames)\n    frame += 1\n    setValues(t)\n    if (frame <= durationInFrames) {\n      previousAnimationId = scheduler.next(loop)\n      step(source)\n    } else {\n      previousAnimationId = 0\n      setTimeout(function() { done(source) }, 0)\n    }\n  }\n\n  function setValues(t) {\n    keys.forEach(function(key) {\n      source[key] = diff[key] * t + start[key]\n    })\n  }\n}\n\nfunction noop() { }\n\nfunction getScheduler(scheduler) {\n  if (!scheduler) {\n    var canRaf = typeof window !== 'undefined' && window.requestAnimationFrame\n    return canRaf ? rafScheduler() : timeoutScheduler()\n  }\n  if (typeof scheduler.next !== 'function') throw new Error('Scheduler is supposed to have next(cb) function')\n  if (typeof scheduler.cancel !== 'function') throw new Error('Scheduler is supposed to have cancel(handle) function')\n\n  return scheduler\n}\n\nfunction rafScheduler() {\n  return {\n    next: window.requestAnimationFrame.bind(window),\n    cancel: window.cancelAnimationFrame.bind(window)\n  }\n}\n\nfunction timeoutScheduler() {\n  return {\n    next: function(cb) {\n      return setTimeout(cb, 1000/60)\n    },\n    cancel: function (id) {\n      return clearTimeout(id)\n    }\n  }\n}\n\nfunction makeAggregateRaf() {\n  var frontBuffer = new Set();\n  var backBuffer = new Set();\n  var frameToken = 0;\n\n  return {\n    next: next,\n    cancel: next,\n    clearAll: clearAll\n  }\n\n  function clearAll() {\n    frontBuffer.clear();\n    backBuffer.clear();\n    cancelAnimationFrame(frameToken);\n    frameToken = 0;\n  }\n\n  function next(callback) {\n    backBuffer.add(callback);\n    renderNextFrame();\n  }\n\n  function renderNextFrame() {\n    if (!frameToken) frameToken = requestAnimationFrame(renderFrame);\n  }\n\n  function renderFrame() {\n    frameToken = 0;\n\n    var t = backBuffer;\n    backBuffer = frontBuffer;\n    frontBuffer = t;\r\n\n    frontBuffer.forEach(function(callback) {\n      callback();\n    });\n    frontBuffer.clear();\n  }\n\n  function cancel(callback) {\n    backBuffer.delete(callback);\n  }\n}\n","module.exports = function eventify(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n","/**\n * Allows smooth kinetic scrolling of the surface\n */\nmodule.exports = kinetic;\n\nfunction kinetic(getPoint, scroll, settings) {\n  if (typeof settings !== 'object') {\n    // setting could come as boolean, we should ignore it, and use an object.\n    settings = {};\n  }\n\n  var minVelocity = typeof settings.minVelocity === 'number' ? settings.minVelocity : 5;\n  var amplitude = typeof settings.amplitude === 'number' ? settings.amplitude : 0.25;\n  var cancelAnimationFrame = typeof settings.cancelAnimationFrame === 'function' ? settings.cancelAnimationFrame : getCancelAnimationFrame();\n  var requestAnimationFrame = typeof settings.requestAnimationFrame === 'function' ? settings.requestAnimationFrame : getRequestAnimationFrame();\n\n  var lastPoint;\n  var timestamp;\n  var timeConstant = 342;\n\n  var ticker;\n  var vx, targetX, ax;\n  var vy, targetY, ay;\n\n  var raf;\n\n  return {\n    start: start,\n    stop: stop,\n    cancel: dispose\n  };\n\n  function dispose() {\n    cancelAnimationFrame(ticker);\n    cancelAnimationFrame(raf);\n  }\n\n  function start() {\n    lastPoint = getPoint();\n\n    ax = ay = vx = vy = 0;\n    timestamp = new Date();\n\n    cancelAnimationFrame(ticker);\n    cancelAnimationFrame(raf);\n\n    // we start polling the point position to accumulate velocity\n    // Once we stop(), we will use accumulated velocity to keep scrolling\n    // an object.\n    ticker = requestAnimationFrame(track);\n  }\n\n  function track() {\n    var now = Date.now();\n    var elapsed = now - timestamp;\n    timestamp = now;\n\n    var currentPoint = getPoint();\n\n    var dx = currentPoint.x - lastPoint.x;\n    var dy = currentPoint.y - lastPoint.y;\n\n    lastPoint = currentPoint;\n\n    var dt = 1000 / (1 + elapsed);\n\n    // moving average\n    vx = 0.8 * dx * dt + 0.2 * vx;\n    vy = 0.8 * dy * dt + 0.2 * vy;\n\n    ticker = requestAnimationFrame(track);\n  }\n\n  function stop() {\n    cancelAnimationFrame(ticker);\n    cancelAnimationFrame(raf);\n\n    var currentPoint = getPoint();\n\n    targetX = currentPoint.x;\n    targetY = currentPoint.y;\n    timestamp = Date.now();\n\n    if (vx < -minVelocity || vx > minVelocity) {\n      ax = amplitude * vx;\n      targetX += ax;\n    }\n\n    if (vy < -minVelocity || vy > minVelocity) {\n      ay = amplitude * vy;\n      targetY += ay;\n    }\n\n    raf = requestAnimationFrame(autoScroll);\n  }\n\n  function autoScroll() {\n    var elapsed = Date.now() - timestamp;\n\n    var moving = false;\n    var dx = 0;\n    var dy = 0;\n\n    if (ax) {\n      dx = -ax * Math.exp(-elapsed / timeConstant);\n\n      if (dx > 0.5 || dx < -0.5) moving = true;\n      else dx = ax = 0;\n    }\n\n    if (ay) {\n      dy = -ay * Math.exp(-elapsed / timeConstant);\n\n      if (dy > 0.5 || dy < -0.5) moving = true;\n      else dy = ay = 0;\n    }\n\n    if (moving) {\n      scroll(targetX + dx, targetY + dy);\n      raf = requestAnimationFrame(autoScroll);\n    }\n  }\n}\n\nfunction getCancelAnimationFrame() {\n  if (typeof cancelAnimationFrame === 'function') return cancelAnimationFrame;\n  return clearTimeout;\n}\n\nfunction getRequestAnimationFrame() {\n  if (typeof requestAnimationFrame === 'function') return requestAnimationFrame;\n\n  return function (handler) {\n    return setTimeout(handler, 16);\n  };\n}","/**\n * Disallows selecting text.\n */\nmodule.exports = createTextSelectionInterceptor;\n\nfunction createTextSelectionInterceptor(useFake) {\n  if (useFake) {\n    return {\n      capture: noop,\n      release: noop\n    };\n  }\n\n  var dragObject;\n  var prevSelectStart;\n  var prevDragStart;\n  var wasCaptured = false;\n\n  return {\n    capture: capture,\n    release: release\n  };\n\n  function capture(domObject) {\n    wasCaptured = true;\n    prevSelectStart = window.document.onselectstart;\n    prevDragStart = window.document.ondragstart;\n\n    window.document.onselectstart = disabled;\n\n    dragObject = domObject;\n    dragObject.ondragstart = disabled;\n  }\n\n  function release() {\n    if (!wasCaptured) return;\n    \n    wasCaptured = false;\n    window.document.onselectstart = prevSelectStart;\n    if (dragObject) dragObject.ondragstart = prevDragStart;\n  }\n}\n\nfunction disabled(e) {\n  e.stopPropagation();\n  return false;\n}\n\nfunction noop() {}\n","module.exports = Transform;\n\nfunction Transform() {\n  this.x = 0;\n  this.y = 0;\n  this.scale = 1;\n}\n","module.exports = makeSvgController;\nmodule.exports.canAttach = isSVGElement;\n\nfunction makeSvgController(svgElement, options) {\n  if (!isSVGElement(svgElement)) {\n    throw new Error('svg element is required for svg.panzoom to work');\n  }\n\n  var owner = svgElement.ownerSVGElement;\n  if (!owner) {\n    throw new Error(\n      'Do not apply panzoom to the root <svg> element. ' +\n      'Use its child instead (e.g. <g></g>). ' +\n      'As of March 2016 only FireFox supported transform on the root element');\n  }\n\n  if (!options.disableKeyboardInteraction) {\n    owner.setAttribute('tabindex', 0);\n  }\n\n  var api = {\n    getBBox: getBBox,\n    getScreenCTM: getScreenCTM,\n    getOwner: getOwner,\n    applyTransform: applyTransform,\n    initTransform: initTransform\n  };\n  \n  return api;\n\n  function getOwner() {\n    return owner;\n  }\n\n  function getBBox() {\n    var bbox =  svgElement.getBBox();\n    return {\n      left: bbox.x,\n      top: bbox.y,\n      width: bbox.width,\n      height: bbox.height,\n    };\n  }\n\n  function getScreenCTM() {\n    var ctm = owner.getCTM();\n    if (!ctm) {\n      // This is likely firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=873106\n      // The code below is not entirely correct, but still better than nothing\n      return owner.getScreenCTM();\n    }\n    return ctm;\n  }\n\n  function initTransform(transform) {\n    var screenCTM = svgElement.getCTM();\n\n    // The above line returns null on Firefox\n    if (screenCTM === null) {\n      screenCTM = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix();\n    }\n\n    transform.x = screenCTM.e;\n    transform.y = screenCTM.f;\n    transform.scale = screenCTM.a;\n    owner.removeAttributeNS(null, 'viewBox');\n  }\n\n  function applyTransform(transform) {\n    svgElement.setAttribute('transform', 'matrix(' +\n      transform.scale + ' 0 0 ' +\n      transform.scale + ' ' +\n      transform.x + ' ' + transform.y + ')');\n  }\n}\n\nfunction isSVGElement(element) {\n  return element && element.ownerSVGElement && element.getCTM;\n}","module.exports = makeDomController;\n\nmodule.exports.canAttach = isDomElement;\n\nfunction makeDomController(domElement, options) {\n  var elementValid = isDomElement(domElement); \n  if (!elementValid) {\n    throw new Error('panzoom requires DOM element to be attached to the DOM tree');\n  }\n\n  var owner = domElement.parentElement;\n  domElement.scrollTop = 0;\n  \n  if (!options.disableKeyboardInteraction) {\n    owner.setAttribute('tabindex', 0);\n  }\n\n  var api = {\n    getBBox: getBBox,\n    getOwner: getOwner,\n    applyTransform: applyTransform,\n  };\n  \n  return api;\n\n  function getOwner() {\n    return owner;\n  }\n\n  function getBBox() {\n    // TODO: We should probably cache this?\n    return  {\n      left: 0,\n      top: 0,\n      width: domElement.clientWidth,\n      height: domElement.clientHeight\n    };\n  }\n\n  function applyTransform(transform) {\n    // TODO: Should we cache this?\n    domElement.style.transformOrigin = '0 0 0';\n    domElement.style.transform = 'matrix(' +\n      transform.scale + ', 0, 0, ' +\n      transform.scale + ', ' +\n      transform.x + ', ' + transform.y + ')';\n  }\n}\n\nfunction isDomElement(element) {\n  return element && element.parentElement && element.style;\n}\n","'use strict';\n/**\n * Allows to drag and zoom svg elements\n */\nvar wheel = require('wheel');\nvar animate = require('amator');\nvar eventify = require('ngraph.events');\nvar kinetic = require('./lib/kinetic.js');\nvar createTextSelectionInterceptor = require('./lib/createTextSelectionInterceptor.js');\nvar domTextSelectionInterceptor = createTextSelectionInterceptor();\nvar fakeTextSelectorInterceptor = createTextSelectionInterceptor(true);\nvar Transform = require('./lib/transform.js');\nvar makeSvgController = require('./lib/svgController.js');\nvar makeDomController = require('./lib/domController.js');\n\nvar defaultZoomSpeed = 1;\nvar defaultDoubleTapZoomSpeed = 1.75;\nvar doubleTapSpeedInMS = 300;\n\nmodule.exports = createPanZoom;\n\n/**\n * Creates a new instance of panzoom, so that an object can be panned and zoomed\n *\n * @param {DOMElement} domElement where panzoom should be attached.\n * @param {Object} options that configure behavior.\n */\nfunction createPanZoom(domElement, options) {\n  options = options || {};\n\n  var panController = options.controller;\n\n  if (!panController) {\n    if (makeSvgController.canAttach(domElement)) {\n      panController = makeSvgController(domElement, options);\n    } else if (makeDomController.canAttach(domElement)) {\n      panController = makeDomController(domElement, options);\n    }\n  }\n\n  if (!panController) {\n    throw new Error(\n      'Cannot create panzoom for the current type of dom element'\n    );\n  }\n  var owner = panController.getOwner();\n  // just to avoid GC pressure, every time we do intermediate transform\n  // we return this object. For internal use only. Never give it back to the consumer of this library\n  var storedCTMResult = { x: 0, y: 0 };\n\n  var isDirty = false;\n  var transform = new Transform();\n\n  if (panController.initTransform) {\n    panController.initTransform(transform);\n  }\n\n  var filterKey = typeof options.filterKey === 'function' ? options.filterKey : noop;\n  // TODO: likely need to unite pinchSpeed with zoomSpeed\n  var pinchSpeed = typeof options.pinchSpeed === 'number' ? options.pinchSpeed : 1;\n  var bounds = options.bounds;\n  var maxZoom = typeof options.maxZoom === 'number' ? options.maxZoom : Number.POSITIVE_INFINITY;\n  var minZoom = typeof options.minZoom === 'number' ? options.minZoom : 0;\n\n  var boundsPadding = typeof options.boundsPadding === 'number' ? options.boundsPadding : 0.05;\n  var zoomDoubleClickSpeed = typeof options.zoomDoubleClickSpeed === 'number' ? options.zoomDoubleClickSpeed : defaultDoubleTapZoomSpeed;\n  var beforeWheel = options.beforeWheel || noop;\n  var beforeMouseDown = options.beforeMouseDown || noop;\n  var speed = typeof options.zoomSpeed === 'number' ? options.zoomSpeed : defaultZoomSpeed;\n  var transformOrigin = parseTransformOrigin(options.transformOrigin);\n  var textSelection = options.enableTextSelection ? fakeTextSelectorInterceptor : domTextSelectionInterceptor;\n\n  validateBounds(bounds);\n\n  if (options.autocenter) {\n    autocenter();\n  }\n\n  var frameAnimation;\n  var lastTouchEndTime = 0;\n  var lastSingleFingerOffset;\n  var touchInProgress = false;\n\n  // We only need to fire panstart when actual move happens\n  var panstartFired = false;\n\n  // cache mouse coordinates here\n  var mouseX;\n  var mouseY;\n\n  var pinchZoomLength;\n\n  var smoothScroll;\n  if ('smoothScroll' in options && !options.smoothScroll) {\n    // If user explicitly asked us not to use smooth scrolling, we obey\n    smoothScroll = rigidScroll();\n  } else {\n    // otherwise we use forward smoothScroll settings to kinetic API\n    // which makes scroll smoothing.\n    smoothScroll = kinetic(getPoint, scroll, options.smoothScroll);\n  }\n\n  var moveByAnimation;\n  var zoomToAnimation;\n\n  var multiTouch;\n  var paused = false;\n\n  listenForEvents();\n\n  var api = {\n    dispose: dispose,\n    moveBy: internalMoveBy,\n    moveTo: moveTo,\n    smoothMoveTo: smoothMoveTo, \n    centerOn: centerOn,\n    zoomTo: publicZoomTo,\n    zoomAbs: zoomAbs,\n    smoothZoom: smoothZoom,\n    smoothZoomAbs: smoothZoomAbs,\n    showRectangle: showRectangle,\n\n    pause: pause,\n    resume: resume,\n    isPaused: isPaused,\n\n    getTransform: getTransformModel,\n\n    getMinZoom: getMinZoom,\n    setMinZoom: setMinZoom,\n\n    getMaxZoom: getMaxZoom,\n    setMaxZoom: setMaxZoom,\n\n    getTransformOrigin: getTransformOrigin,\n    setTransformOrigin: setTransformOrigin,\n\n    getZoomSpeed: getZoomSpeed,\n    setZoomSpeed: setZoomSpeed\n  };\n\n  eventify(api);\n  \n  var initialX = typeof options.initialX === 'number' ? options.initialX : transform.x;\n  var initialY = typeof options.initialY === 'number' ? options.initialY : transform.y;\n  var initialZoom = typeof options.initialZoom === 'number' ? options.initialZoom : transform.scale;\n\n  if(initialX != transform.x || initialY != transform.y || initialZoom != transform.scale){\n    zoomAbs(initialX, initialY, initialZoom);\n  }\n\n  return api;\n\n  function pause() {\n    releaseEvents();\n    paused = true;\n  }\n\n  function resume() {\n    if (paused) {\n      listenForEvents();\n      paused = false;\n    }\n  }\n\n  function isPaused() {\n    return paused;\n  }\n\n  function showRectangle(rect) {\n    // TODO: this duplicates autocenter. I think autocenter should go.\n    var clientRect = owner.getBoundingClientRect();\n    var size = transformToScreen(clientRect.width, clientRect.height);\n\n    var rectWidth = rect.right - rect.left;\n    var rectHeight = rect.bottom - rect.top;\n    if (!Number.isFinite(rectWidth) || !Number.isFinite(rectHeight)) {\n      throw new Error('Invalid rectangle');\n    }\n\n    var dw = size.x / rectWidth;\n    var dh = size.y / rectHeight;\n    var scale = Math.min(dw, dh);\n    transform.x = -(rect.left + rectWidth / 2) * scale + size.x / 2;\n    transform.y = -(rect.top + rectHeight / 2) * scale + size.y / 2;\n    transform.scale = scale;\n  }\n\n  function transformToScreen(x, y) {\n    if (panController.getScreenCTM) {\n      var parentCTM = panController.getScreenCTM();\n      var parentScaleX = parentCTM.a;\n      var parentScaleY = parentCTM.d;\n      var parentOffsetX = parentCTM.e;\n      var parentOffsetY = parentCTM.f;\n      storedCTMResult.x = x * parentScaleX - parentOffsetX;\n      storedCTMResult.y = y * parentScaleY - parentOffsetY;\n    } else {\n      storedCTMResult.x = x;\n      storedCTMResult.y = y;\n    }\n\n    return storedCTMResult;\n  }\n\n  function autocenter() {\n    var w; // width of the parent\n    var h; // height of the parent\n    var left = 0;\n    var top = 0;\n    var sceneBoundingBox = getBoundingBox();\n    if (sceneBoundingBox) {\n      // If we have bounding box - use it.\n      left = sceneBoundingBox.left;\n      top = sceneBoundingBox.top;\n      w = sceneBoundingBox.right - sceneBoundingBox.left;\n      h = sceneBoundingBox.bottom - sceneBoundingBox.top;\n    } else {\n      // otherwise just use whatever space we have\n      var ownerRect = owner.getBoundingClientRect();\n      w = ownerRect.width;\n      h = ownerRect.height;\n    }\n    var bbox = panController.getBBox();\n    if (bbox.width === 0 || bbox.height === 0) {\n      // we probably do not have any elements in the SVG\n      // just bail out;\n      return;\n    }\n    var dh = h / bbox.height;\n    var dw = w / bbox.width;\n    var scale = Math.min(dw, dh);\n    transform.x = -(bbox.left + bbox.width / 2) * scale + w / 2 + left;\n    transform.y = -(bbox.top + bbox.height / 2) * scale + h / 2 + top;\n    transform.scale = scale;\n  }\n\n  function getTransformModel() {\n    // TODO: should this be read only?\n    return transform;\n  }\n\n  function getMinZoom() {\n    return minZoom;\n  }\n\n  function setMinZoom(newMinZoom) {\n    minZoom = newMinZoom;\n  }\n\n  function getMaxZoom() {\n    return maxZoom;\n  }\n\n  function setMaxZoom(newMaxZoom) {\n    maxZoom = newMaxZoom;\n  }\n\n  function getTransformOrigin() {\n    return transformOrigin;\n  }\n\n  function setTransformOrigin(newTransformOrigin) {\n    transformOrigin = parseTransformOrigin(newTransformOrigin);\n  }\n\n  function getZoomSpeed() {\n    return speed;\n  }\n\n  function setZoomSpeed(newSpeed) {\n    if (!Number.isFinite(newSpeed)) {\n      throw new Error('Zoom speed should be a number');\n    }\n    speed = newSpeed;\n  }\n\n  function getPoint() {\n    return {\n      x: transform.x,\n      y: transform.y\n    };\n  }\n\n  function moveTo(x, y) {\n    transform.x = x;\n    transform.y = y;\n\n    keepTransformInsideBounds();\n\n    triggerEvent('pan');\n    makeDirty();\n  }\n\n  function moveBy(dx, dy) {\n    moveTo(transform.x + dx, transform.y + dy);\n  }\n\n  function keepTransformInsideBounds() {\n    var boundingBox = getBoundingBox();\n    if (!boundingBox) return;\n\n    var adjusted = false;\n    var clientRect = getClientRect();\n\n    var diff = boundingBox.left - clientRect.right;\n    if (diff > 0) {\n      transform.x += diff;\n      adjusted = true;\n    }\n    // check the other side:\n    diff = boundingBox.right - clientRect.left;\n    if (diff < 0) {\n      transform.x += diff;\n      adjusted = true;\n    }\n\n    // y axis:\n    diff = boundingBox.top - clientRect.bottom;\n    if (diff > 0) {\n      // we adjust transform, so that it matches exactly our bounding box:\n      // transform.y = boundingBox.top - (boundingBox.height + boundingBox.y) * transform.scale =>\n      // transform.y = boundingBox.top - (clientRect.bottom - transform.y) =>\n      // transform.y = diff + transform.y =>\n      transform.y += diff;\n      adjusted = true;\n    }\n\n    diff = boundingBox.bottom - clientRect.top;\n    if (diff < 0) {\n      transform.y += diff;\n      adjusted = true;\n    }\n    return adjusted;\n  }\n\n  /**\n   * Returns bounding box that should be used to restrict scene movement.\n   */\n  function getBoundingBox() {\n    if (!bounds) return; // client does not want to restrict movement\n\n    if (typeof bounds === 'boolean') {\n      // for boolean type we use parent container bounds\n      var ownerRect = owner.getBoundingClientRect();\n      var sceneWidth = ownerRect.width;\n      var sceneHeight = ownerRect.height;\n\n      return {\n        left: sceneWidth * boundsPadding,\n        top: sceneHeight * boundsPadding,\n        right: sceneWidth * (1 - boundsPadding),\n        bottom: sceneHeight * (1 - boundsPadding)\n      };\n    }\n\n    return bounds;\n  }\n\n  function getClientRect() {\n    var bbox = panController.getBBox();\n    var leftTop = client(bbox.left, bbox.top);\n\n    return {\n      left: leftTop.x,\n      top: leftTop.y,\n      right: bbox.width * transform.scale + leftTop.x,\n      bottom: bbox.height * transform.scale + leftTop.y\n    };\n  }\n\n  function client(x, y) {\n    return {\n      x: x * transform.scale + transform.x,\n      y: y * transform.scale + transform.y\n    };\n  }\n\n  function makeDirty() {\n    isDirty = true;\n    frameAnimation = window.requestAnimationFrame(frame);\n  }\n\n  function zoomByRatio(clientX, clientY, ratio) {\n    if (isNaN(clientX) || isNaN(clientY) || isNaN(ratio)) {\n      throw new Error('zoom requires valid numbers');\n    }\n\n    var newScale = transform.scale * ratio;\n\n    if (newScale < minZoom) {\n      if (transform.scale === minZoom) return;\n\n      ratio = minZoom / transform.scale;\n    }\n    if (newScale > maxZoom) {\n      if (transform.scale === maxZoom) return;\n\n      ratio = maxZoom / transform.scale;\n    }\n\n    var size = transformToScreen(clientX, clientY);\n\n    transform.x = size.x - ratio * (size.x - transform.x);\n    transform.y = size.y - ratio * (size.y - transform.y);\n\n    // TODO: https://github.com/anvaka/panzoom/issues/112\n    if (bounds && boundsPadding === 1 && minZoom === 1) {\n      transform.scale *= ratio;\n      keepTransformInsideBounds();\n    } else {\n      var transformAdjusted = keepTransformInsideBounds();\n      if (!transformAdjusted) transform.scale *= ratio;\n    }\n\n    triggerEvent('zoom');\n\n    makeDirty();\n  }\n\n  function zoomAbs(clientX, clientY, zoomLevel) {\n    var ratio = zoomLevel / transform.scale;\n    zoomByRatio(clientX, clientY, ratio);\n  }\n\n  function centerOn(ui) {\n    var parent = ui.ownerSVGElement;\n    if (!parent)\n      throw new Error('ui element is required to be within the scene');\n\n    // TODO: should i use controller's screen CTM?\n    var clientRect = ui.getBoundingClientRect();\n    var cx = clientRect.left + clientRect.width / 2;\n    var cy = clientRect.top + clientRect.height / 2;\n\n    var container = parent.getBoundingClientRect();\n    var dx = container.width / 2 - cx;\n    var dy = container.height / 2 - cy;\n\n    internalMoveBy(dx, dy, true);\n  }\n\n  function smoothMoveTo(x, y){\n    internalMoveBy(x - transform.x, y - transform.y, true);\n  }\n\n  function internalMoveBy(dx, dy, smooth) {\n    if (!smooth) {\n      return moveBy(dx, dy);\n    }\n\n    if (moveByAnimation) moveByAnimation.cancel();\n\n    var from = { x: 0, y: 0 };\n    var to = { x: dx, y: dy };\n    var lastX = 0;\n    var lastY = 0;\n\n    moveByAnimation = animate(from, to, {\n      step: function (v) {\n        moveBy(v.x - lastX, v.y - lastY);\n\n        lastX = v.x;\n        lastY = v.y;\n      }\n    });\n  }\n\n  function scroll(x, y) {\n    cancelZoomAnimation();\n    moveTo(x, y);\n  }\n\n  function dispose() {\n    releaseEvents();\n  }\n\n  function listenForEvents() {\n    owner.addEventListener('mousedown', onMouseDown, { passive: false });\n    owner.addEventListener('dblclick', onDoubleClick, { passive: false });\n    owner.addEventListener('touchstart', onTouch, { passive: false });\n    owner.addEventListener('keydown', onKeyDown, { passive: false });\n\n    // Need to listen on the owner container, so that we are not limited\n    // by the size of the scrollable domElement\n    wheel.addWheelListener(owner, onMouseWheel, { passive: false });\n\n    makeDirty();\n  }\n\n  function releaseEvents() {\n    wheel.removeWheelListener(owner, onMouseWheel);\n    owner.removeEventListener('mousedown', onMouseDown);\n    owner.removeEventListener('keydown', onKeyDown);\n    owner.removeEventListener('dblclick', onDoubleClick);\n    owner.removeEventListener('touchstart', onTouch);\n\n    if (frameAnimation) {\n      window.cancelAnimationFrame(frameAnimation);\n      frameAnimation = 0;\n    }\n\n    smoothScroll.cancel();\n\n    releaseDocumentMouse();\n    releaseTouches();\n    textSelection.release();\n\n    triggerPanEnd();\n  }\n\n  function frame() {\n    if (isDirty) applyTransform();\n  }\n\n  function applyTransform() {\n    isDirty = false;\n\n    // TODO: Should I allow to cancel this?\n    panController.applyTransform(transform);\n\n    triggerEvent('transform');\n    frameAnimation = 0;\n  }\n\n  function onKeyDown(e) {\n    var x = 0,\n      y = 0,\n      z = 0;\n    if (e.keyCode === 38) {\n      y = 1; // up\n    } else if (e.keyCode === 40) {\n      y = -1; // down\n    } else if (e.keyCode === 37) {\n      x = 1; // left\n    } else if (e.keyCode === 39) {\n      x = -1; // right\n    } else if (e.keyCode === 189 || e.keyCode === 109) {\n      // DASH or SUBTRACT\n      z = 1; // `-` -  zoom out\n    } else if (e.keyCode === 187 || e.keyCode === 107) {\n      // EQUAL SIGN or ADD\n      z = -1; // `=` - zoom in (equal sign on US layout is under `+`)\n    }\n\n    if (filterKey(e, x, y, z)) {\n      // They don't want us to handle the key: https://github.com/anvaka/panzoom/issues/45\n      return;\n    }\n\n    if (x || y) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      var clientRect = owner.getBoundingClientRect();\n      // movement speed should be the same in both X and Y direction:\n      var offset = Math.min(clientRect.width, clientRect.height);\n      var moveSpeedRatio = 0.05;\n      var dx = offset * moveSpeedRatio * x;\n      var dy = offset * moveSpeedRatio * y;\n\n      // TODO: currently we do not animate this. It could be better to have animation\n      internalMoveBy(dx, dy);\n    }\n\n    if (z) {\n      var scaleMultiplier = getScaleMultiplier(z * 100);\n      var offset = transformOrigin ? getTransformOriginOffset() : midPoint();\n      publicZoomTo(offset.x, offset.y, scaleMultiplier);\n    }\n  }\n\n  function midPoint() {\n    var ownerRect = owner.getBoundingClientRect();\n    return {\n      x: ownerRect.width / 2,\n      y: ownerRect.height / 2\n    };\n  }\n\n  function onTouch(e) {\n    // let the override the touch behavior\n    beforeTouch(e);\n\n    if (e.touches.length === 1) {\n      return handleSingleFingerTouch(e, e.touches[0]);\n    } else if (e.touches.length === 2) {\n      // handleTouchMove() will care about pinch zoom.\n      pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n      multiTouch = true;\n      startTouchListenerIfNeeded();\n    }\n  }\n\n  function beforeTouch(e) {\n    // TODO: Need to unify this filtering names. E.g. use `beforeTouch`\n    if (options.onTouch && !options.onTouch(e)) {\n      // if they return `false` from onTouch, we don't want to stop\n      // events propagation. Fixes https://github.com/anvaka/panzoom/issues/12\n      return;\n    }\n\n    e.stopPropagation();\n    e.preventDefault();\n  }\n\n  function beforeDoubleClick(e) {\n    // TODO: Need to unify this filtering names. E.g. use `beforeDoubleClick``\n    if (options.onDoubleClick && !options.onDoubleClick(e)) {\n      // if they return `false` from onTouch, we don't want to stop\n      // events propagation. Fixes https://github.com/anvaka/panzoom/issues/46\n      return;\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  function handleSingleFingerTouch(e) {\n    var touch = e.touches[0];\n    var offset = getOffsetXY(touch);\n    lastSingleFingerOffset = offset;\n    var point = transformToScreen(offset.x, offset.y);\n    mouseX = point.x;\n    mouseY = point.y;\n\n    smoothScroll.cancel();\n    startTouchListenerIfNeeded();\n  }\n\n  function startTouchListenerIfNeeded() {\n    if (touchInProgress) {\n      // no need to do anything, as we already listen to events;\n      return;\n    }\n\n    touchInProgress = true;\n    document.addEventListener('touchmove', handleTouchMove);\n    document.addEventListener('touchend', handleTouchEnd);\n    document.addEventListener('touchcancel', handleTouchEnd);\n  }\n\n  function handleTouchMove(e) {\n    if (e.touches.length === 1) {\n      e.stopPropagation();\n      var touch = e.touches[0];\n\n      var offset = getOffsetXY(touch);\n      var point = transformToScreen(offset.x, offset.y);\n\n      var dx = point.x - mouseX;\n      var dy = point.y - mouseY;\n\n      if (dx !== 0 && dy !== 0) {\n        triggerPanStart();\n      }\n      mouseX = point.x;\n      mouseY = point.y;\n      internalMoveBy(dx, dy);\n    } else if (e.touches.length === 2) {\n      // it's a zoom, let's find direction\n      multiTouch = true;\n      var t1 = e.touches[0];\n      var t2 = e.touches[1];\n      var currentPinchLength = getPinchZoomLength(t1, t2);\n\n      // since the zoom speed is always based on distance from 1, we need to apply\n      // pinch speed only on that distance from 1:\n      var scaleMultiplier =\n        1 + (currentPinchLength / pinchZoomLength - 1) * pinchSpeed;\n\n      var firstTouchPoint = getOffsetXY(t1);\n      var secondTouchPoint = getOffsetXY(t2);\n      mouseX = (firstTouchPoint.x + secondTouchPoint.x) / 2;\n      mouseY = (firstTouchPoint.y + secondTouchPoint.y) / 2;\n      if (transformOrigin) {\n        var offset = getTransformOriginOffset();\n        mouseX = offset.x;\n        mouseY = offset.y;\n      }\n\n      publicZoomTo(mouseX, mouseY, scaleMultiplier);\n\n      pinchZoomLength = currentPinchLength;\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  }\n\n  function handleTouchEnd(e) {\n    if (e.touches.length > 0) {\n      var offset = getOffsetXY(e.touches[0]);\n      var point = transformToScreen(offset.x, offset.y);\n      mouseX = point.x;\n      mouseY = point.y;\n    } else {\n      var now = new Date();\n      if (now - lastTouchEndTime < doubleTapSpeedInMS) {\n        if (transformOrigin) {\n          var offset = getTransformOriginOffset();\n          smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);\n        } else {\n          // We want untransformed x/y here.\n          smoothZoom(lastSingleFingerOffset.x, lastSingleFingerOffset.y, zoomDoubleClickSpeed);\n        }\n      }\n\n      lastTouchEndTime = now;\n\n      triggerPanEnd();\n      releaseTouches();\n    }\n  }\n\n  function getPinchZoomLength(finger1, finger2) {\n    var dx = finger1.clientX - finger2.clientX;\n    var dy = finger1.clientY - finger2.clientY;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  function onDoubleClick(e) {\n    beforeDoubleClick(e);\n    var offset = getOffsetXY(e);\n    if (transformOrigin) {\n      // TODO: looks like this is duplicated in the file.\n      // Need to refactor\n      offset = getTransformOriginOffset();\n    }\n    smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);\n  }\n\n  function onMouseDown(e) {\n    // if client does not want to handle this event - just ignore the call\n    if (beforeMouseDown(e)) return;\n\n    if (touchInProgress) {\n      // modern browsers will fire mousedown for touch events too\n      // we do not want this: touch is handled separately.\n      e.stopPropagation();\n      return false;\n    }\n    // for IE, left click == 1\n    // for Firefox, left click == 0\n    var isLeftButton =\n      (e.button === 1 && window.event !== null) || e.button === 0;\n    if (!isLeftButton) return;\n\n    smoothScroll.cancel();\n\n    var offset = getOffsetXY(e);\n    var point = transformToScreen(offset.x, offset.y);\n    mouseX = point.x;\n    mouseY = point.y;\n\n    // We need to listen on document itself, since mouse can go outside of the\n    // window, and we will loose it\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n    textSelection.capture(e.target || e.srcElement);\n\n    return false;\n  }\n\n  function onMouseMove(e) {\n    // no need to worry about mouse events when touch is happening\n    if (touchInProgress) return;\n\n    triggerPanStart();\n\n    var offset = getOffsetXY(e);\n    var point = transformToScreen(offset.x, offset.y);\n    var dx = point.x - mouseX;\n    var dy = point.y - mouseY;\n\n    mouseX = point.x;\n    mouseY = point.y;\n\n    internalMoveBy(dx, dy);\n  }\n\n  function onMouseUp() {\n    textSelection.release();\n    triggerPanEnd();\n    releaseDocumentMouse();\n  }\n\n  function releaseDocumentMouse() {\n    document.removeEventListener('mousemove', onMouseMove);\n    document.removeEventListener('mouseup', onMouseUp);\n    panstartFired = false;\n  }\n\n  function releaseTouches() {\n    document.removeEventListener('touchmove', handleTouchMove);\n    document.removeEventListener('touchend', handleTouchEnd);\n    document.removeEventListener('touchcancel', handleTouchEnd);\n    panstartFired = false;\n    multiTouch = false;\n    touchInProgress = false;\n  }\n\n  function onMouseWheel(e) {\n    // if client does not want to handle this event - just ignore the call\n    if (beforeWheel(e)) return;\n\n    smoothScroll.cancel();\n\n    var delta = e.deltaY;\n    if (e.deltaMode > 0) delta *= 100;\n\n    var scaleMultiplier = getScaleMultiplier(delta);\n\n    if (scaleMultiplier !== 1) {\n      var offset = transformOrigin\n        ? getTransformOriginOffset()\n        : getOffsetXY(e);\n      publicZoomTo(offset.x, offset.y, scaleMultiplier);\n      e.preventDefault();\n    }\n  }\n\n  function getOffsetXY(e) {\n    var offsetX, offsetY;\n    // I tried using e.offsetX, but that gives wrong results for svg, when user clicks on a path.\n    var ownerRect = owner.getBoundingClientRect();\n    offsetX = e.clientX - ownerRect.left;\n    offsetY = e.clientY - ownerRect.top;\n\n    return { x: offsetX, y: offsetY };\n  }\n\n  function smoothZoom(clientX, clientY, scaleMultiplier) {\n    var fromValue = transform.scale;\n    var from = { scale: fromValue };\n    var to = { scale: scaleMultiplier * fromValue };\n\n    smoothScroll.cancel();\n    cancelZoomAnimation();\n\n    zoomToAnimation = animate(from, to, {\n      step: function (v) {\n        zoomAbs(clientX, clientY, v.scale);\n      },\n      done: triggerZoomEnd\n    });\n  }\n\n  function smoothZoomAbs(clientX, clientY, toScaleValue) {\n    var fromValue = transform.scale;\n    var from = { scale: fromValue };\n    var to = { scale: toScaleValue };\n\n    smoothScroll.cancel();\n    cancelZoomAnimation();\n\n    zoomToAnimation = animate(from, to, {\n      step: function (v) {\n        zoomAbs(clientX, clientY, v.scale);\n      }\n    });\n  }\n\n  function getTransformOriginOffset() {\n    var ownerRect = owner.getBoundingClientRect();\n    return {\n      x: ownerRect.width * transformOrigin.x,\n      y: ownerRect.height * transformOrigin.y\n    };\n  }\n\n  function publicZoomTo(clientX, clientY, scaleMultiplier) {\n    smoothScroll.cancel();\n    cancelZoomAnimation();\n    return zoomByRatio(clientX, clientY, scaleMultiplier);\n  }\n\n  function cancelZoomAnimation() {\n    if (zoomToAnimation) {\n      zoomToAnimation.cancel();\n      zoomToAnimation = null;\n    }\n  }\n\n  function getScaleMultiplier(delta) {\n    var sign = Math.sign(delta);\n    var deltaAdjustedSpeed = Math.min(0.25, Math.abs(speed * delta / 128));\n    return 1 - sign * deltaAdjustedSpeed;\n  }\n\n  function triggerPanStart() {\n    if (!panstartFired) {\n      triggerEvent('panstart');\n      panstartFired = true;\n      smoothScroll.start();\n    }\n  }\n\n  function triggerPanEnd() {\n    if (panstartFired) {\n      // we should never run smooth scrolling if it was multiTouch (pinch zoom animation):\n      if (!multiTouch) smoothScroll.stop();\n      triggerEvent('panend');\n    }\n  }\n\n  function triggerZoomEnd() {\n    triggerEvent('zoomend');\n  }\n\n  function triggerEvent(name) {\n    api.fire(name, api);\n  }\n}\n\nfunction parseTransformOrigin(options) {\n  if (!options) return;\n  if (typeof options === 'object') {\n    if (!isNumber(options.x) || !isNumber(options.y))\n      failTransformOrigin(options);\n    return options;\n  }\n\n  failTransformOrigin();\n}\n\nfunction failTransformOrigin(options) {\n  console.error(options);\n  throw new Error(\n    [\n      'Cannot parse transform origin.',\n      'Some good examples:',\n      '  \"center center\" can be achieved with {x: 0.5, y: 0.5}',\n      '  \"top center\" can be achieved with {x: 0.5, y: 0}',\n      '  \"bottom right\" can be achieved with {x: 1, y: 1}'\n    ].join('\\n')\n  );\n}\n\nfunction noop() { }\n\nfunction validateBounds(bounds) {\n  var boundsType = typeof bounds;\n  if (boundsType === 'undefined' || boundsType === 'boolean') return; // this is okay\n  // otherwise need to be more thorough:\n  var validBounds =\n    isNumber(bounds.left) &&\n    isNumber(bounds.top) &&\n    isNumber(bounds.bottom) &&\n    isNumber(bounds.right);\n\n  if (!validBounds)\n    throw new Error(\n      'Bounds object is not valid. It can be: ' +\n      'undefined, boolean (true|false) or an object {left, top, right, bottom}'\n    );\n}\n\nfunction isNumber(x) {\n  return Number.isFinite(x);\n}\n\n// IE 11 does not support isNaN:\nfunction isNaN(value) {\n  if (Number.isNaN) {\n    return Number.isNaN(value);\n  }\n\n  return value !== value;\n}\n\nfunction rigidScroll() {\n  return {\n    start: noop,\n    stop: noop,\n    cancel: noop\n  };\n}\n\nfunction autoRun() {\n  if (typeof document === 'undefined') return;\n\n  var scripts = document.getElementsByTagName('script');\n  if (!scripts) return;\n  var panzoomScript;\n\n  for (var i = 0; i < scripts.length; ++i) {\n    var x = scripts[i];\n    if (x.src && x.src.match(/\\bpanzoom(\\.min)?\\.js/)) {\n      panzoomScript = x;\n      break;\n    }\n  }\n\n  if (!panzoomScript) return;\n\n  var query = panzoomScript.getAttribute('query');\n  if (!query) return;\n\n  var globalName = panzoomScript.getAttribute('name') || 'pz';\n  var started = Date.now();\n\n  tryAttach();\n\n  function tryAttach() {\n    var el = document.querySelector(query);\n    if (!el) {\n      var now = Date.now();\n      var elapsed = now - started;\n      if (elapsed < 2000) {\n        // Let's wait a bit\n        setTimeout(tryAttach, 100);\n        return;\n      }\n      // If we don't attach within 2 seconds to the target element, consider it a failure\n      console.error('Cannot find the panzoom element', globalName);\n      return;\n    }\n    var options = collectOptions(panzoomScript);\n    console.log(options);\n    window[globalName] = createPanZoom(el, options);\n  }\n\n  function collectOptions(script) {\n    var attrs = script.attributes;\n    var options = {};\n    for (var j = 0; j < attrs.length; ++j) {\n      var attr = attrs[j];\n      var nameValue = getPanzoomAttributeNameValue(attr);\n      if (nameValue) {\n        options[nameValue.name] = nameValue.value;\n      }\n    }\n\n    return options;\n  }\n\n  function getPanzoomAttributeNameValue(attr) {\n    if (!attr.name) return;\n    var isPanZoomAttribute =\n      attr.name[0] === 'p' && attr.name[1] === 'z' && attr.name[2] === '-';\n\n    if (!isPanZoomAttribute) return;\n\n    var name = attr.name.substr(3);\n    var value = JSON.parse(attr.value);\n    return { name: name, value: value };\n  }\n}\n\nautoRun();\n\t","<script>\n\n\timport {onMount} from 'svelte'\n\texport let title = ''\n\texport let top = null\n\texport let left = null\n\texport let right = null\n\texport let bottom = null\n\texport let minimised = false\n\n\tconst SAY = m => console.log(`[Panel] ${m}`)\n\tconst w = window\n\n\t$: x = left ? left : right * -1\n\t$: y = top ? top : bottom * -1\n\t$: key = `Panel_${title.replaceAll(' ', '_')}`\n\n\tlet grabbing = false\n\tlet og = null\n\tlet store = null\n\n\tonMount(async e => {\n\t\tif (title != '') {\n\t\t\ttry {\n\t\t\t\tconst o = JSON.parse(w.localStorage.getItem(key))\n\t\t\t\ttop = o.top\n\t\t\t\tleft = o.left\n\t\t\t\tright = o.right\n\t\t\t\tbottom = o.bottom\n\t\t\t\tminimised = o.minimised\n\t\t\t\tSAY(`💠 loaded ${key} positions`)\n\t\t\t\tconsole.log({top,left,right,bottom})\n\t\t\t} catch(err) {}\n\t\t}\n\t})\n\n\tlet timeout = null\n\t$: (o => {\n\t\tif (timeout) clearTimeout(timeout)\n\t\ttimeout = setTimeout(e => {\n\t\t\tSAY(`💠 stored`)\n\t\t\tw.localStorage.setItem( key, JSON.stringify({top,left,right,bottom,minimised}))\n\t\t}, 400)\n\t})({top,left,right,bottom,minimised})\n\n\tfunction onMousemove(e) {\n\t\tif (grabbing) {\n\t\t\tconst {clientX, clientY} = e\n\t\t\tif (left != null) left = store.left - (og.clientX - clientX)\n\t\t\tif (right != null) right = store.right + (og.clientX - clientX)\n\t\t\tif (top != null) top = store.top - (og.clientY - clientY)\n\t\t\tif (bottom != null) bottom = store.bottom + (og.clientY - clientY)\n\n\t\t}\n\t}\n\n\t// function setBoundaries(e) {\n\t// \tif (left != null) {\n\t// \t\tif (left < 0) left = 0\n\t// \t}\n\t// }\n\tfunction onMouseup(e) {\n\t\tif (w.zoomer) w.zoomer.resume()\n\t\tgrabbing = false\n\t}\n\n\tfunction onMousedown(e) {\n\t\tif (w.zoomer) w.zoomer.pause()\n\t\tconst no = ['textarea','number','text']\n\t\tif (no.indexOf(e.target.type) != -1) return\n\t\tgrabbing = true\n\t\tconst {clientX, clientY} = e\n\t\tog = {clientX, clientY}\n\t\tstore = {top,left,right,bottom}\n\t\t\n\t}\n</script>\n\n<svelte:window on:mouseup={onMouseup} on:mousemove={onMousemove} />\n\n<div \n\tclass:t0={top}\n\tclass:l0={left}\n\tclass:r0={right}\n\tclass:b0={bottom}\n\ton:mousedown={onMousedown}\n\tstyle=\"transform: translate({x}px, {y}px)\"\n\tclass=\"flex column abs\">\n\t<header \n\t\tclass=\"flex row bb pop border\">\n\t\t<div \n\t\t\tclass=\"grow p0-5 minh2em\">\n\t\t\t{title}\n\t\t</div>\n\t\t<div \n\t\t\tclass=\"pointer p0-5 flex\">\n\t\t\t<div \n\t\t\t\ton:click={e => (minimised = !minimised)}\n\t\t\t\tclass:dash={minimised}\n\t\t\t\tclass=\"minw1em border clickable\" />\n\t\t</div>\n\t</header>\n\t<div \n\t\tclass=\"flex column\"\n\t\tclass:invisible={minimised}>\n\t\t<div class=\"bg flex column bl br bb\">\n\t\t\t<slot />\n\t\t</div>\n\t</div>\n</div>","\nexport const MODE_RECT = 'rectangle'\nexport const MODE_POINTER = 'pointer'\nexport const MODE_SELECT = 'select'\nexport const MODE_CHAR = 'char'\nexport const SPACE = '&nbsp;'\nexport const ALIGN_START = 'start'\nexport const ALIGN_CENTER = 'center'\nexport const ALIGN_END = 'end'\nexport const ALIGN_JUSTIFY = 'justify'\n\nexport const INPUT_ELEMENTS = ['textarea','number','text']\n\n// use this:\n\n// https://www.w3.org/TR/xml-entity-names/025.html\n\nexport const MODES = {\n\t[MODE_POINTER]: {},\n\t[MODE_SELECT]: {},\n\t[MODE_CHAR]: {},\n\t[MODE_RECT]: {}\n}\n\nexport const CIRCLES = [ '⃝', '⃠', '↺', '↻', '⇴', '⌼', '⌽', '⌾', '⍉', '⍜', '⍟', '⍥', '⎋', '⏀', '⏁', '⏂', '⏣', '○', '◌', '◍', '●', '◐', '◑', '◒', '◓', '◔', '◕', '◖', '◗', '◙', '◚', '◛', '◠', '◡', '◯', '◴', '◵', '◶', '◷', '⚆', '⚇', '⚈', '⚉','⚬', '❍', '⟟', '⟲', '⟳', '⥀', '⥁', '⥈', '⥉', '⦲', '⦵', '⦺', '⦻', '⦽', '⧂', '⧃', '⧇', '⧬', '⧭', '⧲', '⧳', '⨢', '⨭', '⨮', '⨴', '⨵', '⨷', '⩹', '⩺', '⫯', '⫰', '⫱', '⬤', '⬰','￮', '𐩑', '𐩒', '𑗘', '𑗙', '𑗚', '𛲅', '𛲕']\nexport const INPUT_KEYS = [ 'Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5', 'Digit6', 'Digit7', 'Digit8', 'Digit9', 'Digit0', 'Minus', 'Equal', 'KeyQ', 'KeyW', 'KeyE', 'KeyR', 'KeyT', 'KeyY', 'KeyU', 'KeyI', 'KeyO', 'KeyP', 'BracketLeft', 'BracketRight', 'KeyA', 'KeyS', 'KeyD', 'KeyF', 'KeyG', 'KeyH', 'KeyJ', 'KeyK', 'KeyL', 'Semicolon', 'Quote', 'Backslash', 'KeyZ', 'KeyX', 'KeyC', 'KeyV', 'KeyB', 'KeyN', 'KeyM', 'Comma', 'Period', 'Slash' ]\n\nexport const SQUARE_CORNERS = {\n\ttl: ['╭','┌','┍','┎','┏','╭','╔','╒','╓'],\n\ttr: ['╮','┐','┑','┒','┓','╮','╗','╕','╖'],\n\tbl: ['╰','└','┕','┖','┗','╰','╚','╘','╙'],\n\tbr: ['╯','┘','┙','┚','┛','╯','╝','╛','╜'],\n}\n\nexport const DIAGONAL = ['╲','╱','╳']\n\nexport const LINES = {\n\tv: ['│','┃','┆','┇','┊','┋','╎','╏','╽','╿','╵','╷','╹','╻'],\n\th: ['─','━','┄','┅','┈','┉','╌','╍','╼','╾','╴','╶','╸','╺']\n}\nexport const ARROWS = ['←','↑','→','↓','↔','↕','↖','↗','↘','↙','↚','↛','↜','↝','↞','↟','↠','↡','↢','↣','↤','↥','↦','↧','↨','↩','↪','↫','↬','↭','↮','↯','↰','↱','↲','↳','↴','↵','↶','↷','↸','↹','↺','↻','⇄','⇅','⇆','⇇','⇈','⇉','⇊','⇍','⇎','⇏','⇐','⇑','⇒','⇓','⇔','⇕','⇖','⇗','⇘','⇙','⇚','⇛','⇜','⇝','⇞','⇟','⇠','⇡','⇢','⇣','⇤','⇥','⇦','⇧','⇨','⇩','⇪'\n]\nexport const BLOCKS = ['▀','▁','▂','▃','▄','▅','▆','▇','█','▉','▊','▋','▌','▍','▎','▏','▐','░','▒','▓','▔','▕','▖','▗','▘','▙','▚','▛','▜','▝','▞','▟']\n\n\nexport const KEYS = [ 'KeyQ', 'KeyW', 'KeyE', 'KeyR', 'KeyT', 'KeyY', 'KeyU', 'KeyI', 'KeyO', 'KeyP', 'BracketLeft', 'BracketRight', 'KeyA', 'KeyS', 'KeyD', 'KeyF', 'KeyG', 'KeyH', 'KeyJ', 'KeyK', 'KeyL', 'Semicolon', 'Quote', 'Backslash', 'KeyZ', 'KeyX', 'KeyC', 'KeyV', 'KeyB', 'KeyN', 'KeyM', 'Comma', 'Period', 'Slash' ]\nexport const KEYS_ICONS = [ 'Q','W','E','R','T','Y','U','I','O','P','[',']','A','S','D','F','G','H','J','K','L',';','\\'','\\\\','Z','X','C','V','B','N','M',',','.','/']\n\n\nexport const LOREM = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi id sagittis orci, non rhoncus velit. Nam sed tellus cursus, interdum nulla ac, iaculis libero. Nam ullamcorper nulla sem, id gravida dui posuere vitae. Morbi finibus ultrices ligula id varius. Ut lobortis ornare nisl in efficitur. Mauris viverra est malesuada, feugiat tellus in, faucibus risus. Vivamus sed lacinia diam. Cras in ullamcorper lacus, ac euismod ex.'\n\nexport const BOARDS = [\n\t[...KEYS_ICONS],\n\t[...BLOCKS],\n\t[...LINES.h,...LINES.v,...DIAGONAL],\n\t[...SQUARE_CORNERS.tl,...SQUARE_CORNERS.tr,...SQUARE_CORNERS.bl,...SQUARE_CORNERS.br],\n\t[...CIRCLES]\n]\n\nexport const BOARD_NAMES = ['Default', 'Blocks', 'Lines', 'Corners', 'Circles']\n","const w = window\n\nimport { SQUARE_CORNERS, LINES, ARROWS, BLOCKS, KEYS, LOREM } from './Defs.js'\nimport { MODE_RECT, MODE_TEXT, MODE_POINTER, MODE_SELECT, MODE_CHAR, SPACE } from './Defs.js'\nimport { ALIGN_CENTER, ALIGN_END, ALIGN_START, ALIGN_JUSTIFY } from './Defs.js'\n\n\nconst SAY = m => console.log(`[Chars] ${m}`)\n\nexport function setRectChars() {\n\n\tif (!w.ACTIVE || w?.ACTIVE?.type != MODE_RECT) return\n\n\tlet { start, end } = w.ACTIVE\n\tSAY(`🟦 set`)\n\n\tfor (let y = 0; y < height; y++) {\n\t\tfor (let x = 0; x < width; x++) {\n\n\t\t\tif (!w.ACTIVE.chars[y]) w.ACTIVE.chars[y] = []\n\n\t\t\tconst topBottom = (y == start.y || y == end.y)\n\t\t\tconst leftRight = (x == start.x || x == end.x)\n\n\t\t\tconst withinX = (x >= start.x && x <= end.x)\n\t\t\tconst withinY = (y >= start.y && y <= end.y)\n\n\t\t\tconst tl = (y == start.y && x == start.x )\n\t\t\tconst tr = (y == start.y && x == end.x )\n\t\t\tconst br = (y == end.y && x == end.x )\n\t\t\tconst bl = (y == end.y && x == start.x )\n\n\t\t\tlet sel = true\n\t\t\tconst _BLOCK = BLOCKS[w.ACTIVE.fill]\n\n\t\t\tif (tl) {\n\t\t\t\tw.ACTIVE.chars[y][x] = SQUARE_CORNERS.tl[w.ACTIVE.corner] || _BLOCK\n\t\t\t} else if (tr) {\n\t\t\t\tw.ACTIVE.chars[y][x] = SQUARE_CORNERS.tr[w.ACTIVE.corner] || _BLOCK\n\t\t\t} else if (br) {\n\t\t\t\tw.ACTIVE.chars[y][x] = SQUARE_CORNERS.br[w.ACTIVE.corner] || _BLOCK\n\t\t\t} else if (bl) {\n\t\t\t\tw.ACTIVE.chars[y][x] = SQUARE_CORNERS.bl[w.ACTIVE.corner] || _BLOCK\n\t\t\t} else if ( topBottom && withinX ) {\n\t\t\t\tw.ACTIVE.chars[y][x] = LINES.h[w.ACTIVE.sides] || _BLOCK\n\t\t\t} else if ( leftRight && withinY ) {\n\t\t\t\tw.ACTIVE.chars[y][x] = LINES.v[w.ACTIVE.sides] || _BLOCK \n\t\t\t} else if ( withinX && withinY && typeof w.ACTIVE.fill == 'number' ) {\n\t\t\t\tw.ACTIVE.chars[y][x] = _BLOCK\n\t\t\t} else {\n\t\t\t\tw.ACTIVE.chars[y][x] = null\n\t\t\t\tsel = false\n\t\t\t}\n\n\t\t\tif (sel) {\n\t\t\t\tif (!w.HIGH[y]) w.HIGH[y] = []\n\t\t\t\tw.HIGH[y][x] = true\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nexport function setTextChars() {\n\n\tif (!w.ACTIVE) return\n\tif (w?.ACTIVE?.type != MODE_RECT) return\n\tSAY(`🔠 set`)\n\n\t// make exact copy\n\n\tlet { start, end, padding, whitespace } = { \n\t\tstart: {...w.ACTIVE.start}, \n\t\tend: {...w.ACTIVE.end},\n\t\tpadding: w.ACTIVE.padding,\n\t\twhitespace: w.ACTIVE.whitespace\n\t}\n\n\t// indent if no corners or sides\n\n\tconst bC = w.ACTIVE.corner >= 0 && w.ACTIVE.corner != null \n\tconst bS = w.ACTIVE.sides >= 0 && w.ACTIVE.sides != null\n\n\tif (bC || bS) {\n\t\tstart.x += 1 + padding\n\t\tstart.y += 1 + padding\n\t\tend.x -= 1 + padding\n\t\tend.y -= 1 + padding\n\t}\n\n\tconst alignX = w.ACTIVE?.alignX || ALIGN_CENTER\n\tconst alignY = w.ACTIVE?.alignY || ALIGN_CENTER\n\n\tconsole.log(`[App] setting textbox with x \"${alignX}\" and y \"${alignY}\"` )\n\n\tconst blockWidth = end.x - start.x\n\tconst blockHeight = end.y - start.y\n\n\n\t// create lines\n\n\tw.ACTIVE.text = w.ACTIVE.text || ''\n\tw.ACTIVE.lines = []\n\tlet currentLine = ''\n\tlet idx = 0\n\n\tfor (const paragraph of w.ACTIVE.text.split('\\n')) {\n\n\t\tfor (const word of paragraph.split(' ')) {\n\n\t\t\tif (currentLine.length + word.length + 1 < blockWidth) {\n\t\t\t\tconst space = currentLine != '' ? ' ' : ''\n\t\t\t\tcurrentLine += space + word\n\t\t\t} else {\n\t\t\t\tw.ACTIVE.lines.push( currentLine )\n\t\t\t\tcurrentLine = word\n\t\t\t}\n\t\t}\n\n\t\tw.ACTIVE.lines.push(currentLine)\n\t\tcurrentLine = ''\n\n\t}\n\n\t// w.ACTIVE.chars.length = 0\n\n\t// return \n\tconst { lines } = w.ACTIVE\n\tconst yDiff = blockHeight - w.ACTIVE.lines.length\n\tconst aYCenter = alignY == ALIGN_CENTER && blockHeight > lines.length\n\tconst aXCenter = alignX == ALIGN_CENTER\n\tconst aYEnd = alignY == ALIGN_END && blockHeight > lines.length\n\tconst aXEnd = alignX == ALIGN_END\n\n\n\tfor (let y = start.y; y <= end.y; y++) {\n\t\tfor (let x = start.x; x <= end.x; x++) {\n\n\t\t\tif (!w.ACTIVE.chars[y]) w.ACTIVE.chars[y] = []\n\n\t\t\tlet yy = y - start.y\n\t\t\tlet xx = x - start.x\n\n\t\t\t// [Y]\n\n\t\t\tif ( aYCenter ) yy -= (yDiff / 2) + 0.5\n\t\t\tif ( aYEnd ) yy -= yDiff + 1\n\n\t\t\tyy = Math.round(yy)\n\n\t\t\tconst line = lines?.[yy]\n\n\t\t\t// [X]\n\n\t\t\tconst xDiff = blockWidth - line?.length\n\t\t\tif ( aXCenter && line ) xx -= Math.round(xDiff / 2)\n\t\t\tif ( aXEnd && line ) xx -= Math.round(xDiff) + 1\n\n\t\t\txx = Math.round(xx)\n\n\t\t\tconst char = line?.[xx]\n\t\t\t// w.ACTIVE.chars[y][x] = (!char || char == ' ') ? SPACE : char\n\n\t\t\tif (char) w.ACTIVE.chars[y][x] = char\n\t\t\tif (!char && whitespace) w.ACTIVE.chars[y][x] = SPACE\n\t\t\t// w.ACTIVE.chars[y][x] = '!'\n\t\t\tif (!w.HIGH[y]) w.HIGH[y] = []\n\t\t\tw.HIGH[y][x] = true\n\t\t}\n\t}\n}\n\n\nexport function setCharChars() {\n\n\tif (!w.ACTIVE || w?.ACTIVE?.type != MODE_CHAR) return\n\tSAY(`🅰️ set`)\n\n\tlet { start, end, inputs } = w.ACTIVE\n\n\tconst blockWidth = end.x - start.x\n\tconst blockHeight = end.y - start.y\n\n\tconst { x, y } = w.ACTIVE.origin\n\n\tconsole.log(`[App] setting chars from origin ${x}/${y}` )\n\n\t// create lines\n\n\tfor (let y = 0; y <= w.height; y++) {\n\t\tfor (let x = 0; x <= w.width; x++) {\n\t\t\tif (!w.ACTIVE.chars[y]) w.ACTIVE.chars[y] = []\n\t\t\tw.ACTIVE.chars[y][x] = inputs?.[y]?.[x] || null\n\t\t}\n\t}\n}\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { writable } from 'svelte/store'\nimport { MODE_TEXT, MODE_RECT } from './Defs.js'\n\nexport const _keys = writable({})\nexport const _keyboardIdx = writable(0)\nexport const _showKeyboard = writable(false)\nexport const _activeElement = writable(null)\nexport const _mode = writable(MODE_RECT)","function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange;\n\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2;\n\n          // Overlapping\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3;\n\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };\n","import { MODE_CHAR, INPUT_KEYS, SPACE, BOARDS, KEYS, INPUT_ELEMENTS, MODES } from './Defs.js'\nimport { get, set } from 'svelte/store'\nimport { _keyboardIdx, _keys, _activeElement, _mode } from './Store.js'\nimport * as diff from 'diff'\n\nnavigator.keyboard.getLayoutMap().then(keyboardLayoutMap => {\n\tw.keyboardLayoutMap = keyboardLayoutMap\n\n\tconst input = document.getElementById('capture')\n\tconsole.log(input)\n\tinput.addEventListener('keydown', e => {\n\t\t// console.log('Layout keydown', e.key, e)\n\t})\n\tinput.dispatchEvent(new Event('focus'));\n\tinput.dispatchEvent(new KeyboardEvent('keydown',{'code':'KeyQ'}));\n\tconsole.log(`[Keys] keyboardLayoutMap`, Object.keys(keyboardLayoutMap), Object.values(keyboardLayoutMap))\n})\n\n\nconst w = window\n\nconst META = 'MetaLeft'\nconst ARROWKEYS = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown']\n\nconst getStores = e => {\n\n\tconst keyboardIdx = get(_keyboardIdx)\n\tconst board = BOARDS[keyboardIdx]\n\tconst char = board[KEYS.indexOf(e.code)]\n\n\treturn {\n\t\tkeys: get(_keys),\n\t\tkeyboardIdx,\n\t\tboard,\n\t\tchar,\n\t\tmode: get(_mode),\n\t\tmodes: Object.keys(MODES),\n\t\tactiveElement: get(_activeElement),\n\t\tnumber: (e?.keyCode || 0) - 49\n\t}\n}\n\nlet keyboardWasTabbed = false\n\nconst SAY = m => console.log(`[Keys] ${m}`)\n\nlet previousTextValue = null\nlet textboxIsPressed = false\n\nexport async function onTextboxKeydown( e ) {\n\tSAY(`👇👇 textbox keydown ${e.target.value.length} chars`)\n\n\tif (e.key.length > 1 || e.metaKey || e.ctrlKey) return\n\n\tconst { target } = e\n\tconst { value, selectionStart, selectionEnd } = target\n\tconst { char } = getStores(e)\n\tconst { lengt } = value\n\n\n\te.target.value = w.ACTIVE.text = `${value.substring(0,selectionStart)}${char || e.key}${value.substring(selectionEnd)}`\n\te.target.setSelectionRange(selectionStart+1, selectionStart+1)\n\n\te.preventDefault()\n}\nexport async function onTextboxKeyup( e ) {\n\tSAY(`👆👆 textbox keyup ${e.target.value.length} chars`)\n\n\n}\n\nexport async function onKeyup( e ) {\n\n\tSAY(`👆 ${e.code}`)\n\n\tlet { \n\t\tmode, \n\t\tmodes, \n\t\tkeys, \n\t\tkeyboardIdx, \n\t\tactiveElement, \n\t\tnumber, \n\t\tboard, \n\t\tchar } = getStores(e)\n\n\tif (INPUT_ELEMENTS.indexOf(activeElement?.type) != -1) {\n\n\t\tif (e.code == 'Tab' && !keyboardWasTabbed) {\n\t\t\tkeyboardIdx += 1\n\t\t\tif (keyboardIdx >= BOARDS.length) keyboardIdx = 0\n\t\t\tSAY(`⌨️ tab to keyboard ${keyboardIdx}`)\n\t\t\t_keyboardIdx.set(keyboardIdx)\n\t\t\te.preventDefault()\n\t\t}\n\t}\n}\n\nexport async function onKeydown( e ) {\n\n\tconst layoutKey = keyboardLayoutMap.get(e.code)\n\n\tSAY(`👇 ${e.code}`)\n\n\tconst tools = Object.keys(w.TOOLS)\n\n\tlet { \n\t\tmode, \n\t\tmodes, \n\t\tkeys, \n\t\tkeyboardIdx, \n\t\tactiveElement, \n\t\tnumber, \n\t\tboard, \n\t\tchar } = getStores(e)\n\n\tif (e.code == 'Tab') e.preventDefault()\n\n\n\tif (INPUT_ELEMENTS.indexOf(activeElement.type) != -1) {\n\n\t\t// Input or Textarea is selected\n\n\t\tSAY(`🔡 using ${INPUT_ELEMENTS.join(', ')}`)\n\n\t\tif (e.code == 'Escape') {\n\n\t\t\tSAY(`🚪 blurring ${activeElement.type}`)\n\t\t\tactiveElement.blur()\n\t\t}\n\n\t\tif (keys['Tab']) {\n\t\t\tif (number >= 0 && number < BOARDS.length) {\n\t\t\t\tSAY(`⌨️ tabbed keyboard to index ${number}`)\n\t\t\t\tkeyboardIdx = number\n\t\t\t\t_keyboardIdx.set(keyboardIdx)\n\t\t\t\tkeyboardWasTabbed = true\n\t\t\t} else {\n\t\t\t\tkeyboardWasTabbed = false\n\t\t\t}\n\t\t\te.preventDefault()\n\t\t}\n\n\t} else if (number >= 0 && number < modes.length) {\n\n\t\t// Tab = change tool\n\n\t\tSAY(`🛠 tabbed mode to index ${number}`)\n\t\tmode = modes[number]\n\t\t_mode.set(mode)\n\n\n\t} else if (e.code == 'Escape') {\n\n\t\t// Escape = deactivate things\n\n\t\tw.ACTIVE = null\n\n\t} else if ( e.code == 'KeyC' && keys[META] && w.ACTIVE ) {\n\n\t\tconst { start, end } = w.ACTIVE\n\n\t\tconsole.log(`[Keys] copying from`, start, end )\n\n\t\tlet _CLIP = ''\n\t\tfor (let y = start.y; y <= end.y; y++) {\n\t\t\tfor (let x = start.x; x <= end.x; x++) {\n\t\t\t\t_CLIP += w.OUT?.[y]?.[x] || SPACE\n\t\t\t}\n\t\t\tif (y != end.y) _CLIP += '\\n'\n\t\t}\n\t\t_CLIP = _CLIP.replaceAll(SPACE,' ')\n\n\t\tif (!navigator.clipboard) return alert('no clipboard api!')\n\t    await navigator.clipboard.writeText(_CLIP)\n\t\tconsole.log(`[Keys] text copied\\n`, _CLIP)\n\n\t} else if ( ARROWKEYS.indexOf(e.code) != -1 && w.ACTIVE ) {\n\t\tconsole.log(`[Keys] move ${e.code}`,)\n\n\t\tconst _UNIT = keys['ShiftLeft'] ? 4 : 1\n\n\t\tif (e.code == 'ArrowLeft') {\n\t\t\tw.ACTIVE.start.x -= _UNIT\n\t\t\tw.ACTIVE.end.x -= _UNIT\n\t\t} else if (e.code == 'ArrowRight') {\n\t\t\tw.ACTIVE.start.x += _UNIT\n\t\t\tw.ACTIVE.end.x += _UNIT\n\t\t} else if (e.code == 'ArrowUp') {\n\t\t\tw.ACTIVE.start.y -= _UNIT\n\t\t\tw.ACTIVE.end.y -= _UNIT\n\t\t} else if (e.code == 'ArrowDown') {\n\t\t\tw.ACTIVE.start.y += _UNIT\n\t\t\tw.ACTIVE.end.y += _UNIT\n\t\t}\n\n\t} else if (INPUT_KEYS.indexOf(e.code) != -1 && w.MODE == MODE_CHAR && w.ACTIVE?.type == MODE_CHAR) {\n\t\tconsole.log(`[Keys] fill chars with ${e.code}`, w.ACTIVE)\n\n\t\tconst { start, end } = w.ACTIVE\n\t\tfor (let y = start.y; y <= end.y; y++) {\n\t\t\tfor (let x = start.x; x <= end.x; x++) {\n\t\t\t\tif (!w.ACTIVE.inputs[y]) w.ACTIVE.inputs[y] = {}\n\t\t\t\tw.ACTIVE.inputs[y][x] = char\n\t\t\t}\n\t\t}\n\n\n\t} else if ( e.key == 'Backspace' && w.ACTIVE ) {\n\n\n\n\t\tconsole.log('[Keys] deleting layer')\n\t\tlet cp = w.DATA\n\t\tlet idx = w.DATA.indexOf( w.DATA.find( l => l.ref == w.ACTIVE.ref ) )\n\t\tif (idx == -1) {\n\t\t\treturn console.log(`[Keys] error finding index of selected`)\n\t\t}\n\t\tcp.splice( idx, 1 )\n\t\tw.DATA = cp\n\t\tw.ACTIVE = null\n\n\t}\n}","<script>\n\n\timport { MODE_CHAR, KEYS, KEYS_ICONS, BLOCKS, SQUARE_CORNERS, LINES, DIAGONAL, ARROWS, BOARDS, BOARD_NAMES, INPUT_ELEMENTS } from './Defs.js'\n\timport { _keys, _showKeyboard, _keyboardIdx, _activeElement } from './Store.js'\n\n\tconst pattern = [12,12,10]\n\n\tconst w = window\n\n\n\tfunction setActiveElement(event) {\n\t\t$_activeElement = document.activeElement\n\t\t$_showKeyboard = INPUT_ELEMENTS.indexOf($_activeElement?.type) != -1 || w.MODE == MODE_CHAR\n\t}\n\t\n\tdocument.addEventListener('focus', setActiveElement, true)\n\tdocument.addEventListener('blur', setActiveElement, true)\n\n\tfunction onSetIndex(idx) {\n\t\t$_keyboardIdx = idx \n\t}\n\n\tlet currentlyPressed = null\n\tfunction onKeyMousedown(i, ii) {\n\t\tconst idx = i+(ii*12)\n\t\tcurrentlyPressed = idx\n\t}\n\n\tfunction isKeyActive(i, ii, kys, curp, show) {\n\t\tconst idx = i+(ii*12)\n\t\treturn ( ( kys[KEYS[idx]] && show ) || curp == idx)\n\t}\n\n\tfunction getKeyIcon(i, ii) {\n\t\tconst idx = i+(ii*12)\n\t\treturn KEYS_ICONS[idx].toLowerCase()\n\t}\n\tfunction getKeySymbol(i,ii,kidx) {\n\t\tconst idx = i+(ii*12)\n\t\treturn BOARDS[kidx]?.[idx] || ''\n\t}\n</script>\n\n<svelte:window on:mouseup={e => (currentlyPressed = null)} />\n<div class=\"flex column w100pc\">\n\t<div class=\"flex row\">\n\t\t{#each BOARD_NAMES as name,idx }\n\t\t\t<div class=\"pointer\">\n\t\t\t\t<div \n\t\t\t\t\ton:mousedown={e => onSetIndex(idx)}\n\t\t\t\t\tclass=\"flex bg row-center-center p0-5\"\n\t\t\t\t\tclass:filled={$_keyboardIdx == idx}>\n\t\t\t\t\t{name}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t{/each}\n\t</div>\n\t<div \n\t\tid=\"keyboard\" \n\t\tclass:fade={!$_showKeyboard}\n\t\tclass=\"flex column w100pc bl1-solid bt1-solid\">\n\t\t{#each pattern as count, ii}\n\t\t\t<div \n\t\t\t\tclass=\"flex row\">\n\n\t\t\t\t{#each new Array(count) as num, i}\n\n\t\t\t\t\t<div \n\t\t\t\t\t\tclass:fade={!$_showKeyboard}\n\t\t\t\t\t\tclass:filled={ isKeyActive(i, ii, $_keys, currentlyPressed, $_showKeyboard) }\n\t\t\t\t\t\tclass=\"grow ptb0-5 pointer flex column-center-center br1-solid bb1-solid no-basis bg\"\n\t\t\t\t\t\ton:mousedown={ e => onKeyMousedown(i, ii)}>\n\t\t\t\t\t\t<span class=\"pb0-4\">\n\t\t\t\t\t\t\t{getKeyIcon(i,ii)}\n\t\t\t\t\t\t</span> \n\t\t\t\t\t\t<span class=\"f3\">{getKeySymbol(i,ii,$_keyboardIdx)}</span>\n\t\t\t\t\t</div>\n\t\t\t\t{/each}\n\t\t\t\t{#if count == 10}\n\t\t\t\t\t<span class=\"grow\" />\n\t\t\t\t\t<span class=\"grow\" />\n\t\t\t\t{/if}\n\t\t\t</div>\n\t\t{/each}\n\n\t</div>\n</div>","<script>\n\timport panzoom from 'panzoom'\n\timport { onMount } from 'svelte'\n\timport Panel from './Panel.svelte'\n\timport { SQUARE_CORNERS, LINES, ARROWS, BLOCKS, KEYS, LOREM } from './Defs.js'\n\timport { MODE_RECT, MODE_POINTER, MODE_SELECT, MODE_CHAR, SPACE, MODES } from './Defs.js'\n\timport { ALIGN_CENTER, ALIGN_END, ALIGN_START, ALIGN_JUSTIFY } from './Defs.js'\n\timport { INPUT_KEYS } from './Defs.js'\n\n\timport { setTextChars, setRectChars, setCharChars } from './Chars.js'\n\timport { onKeyup, onKeydown, onTextboxKeyup, onTextboxKeydown } from './Keys.js'\n\timport { _keys, _mode } from './Store.js'\n\n\timport Keyboard from './Keyboard.svelte'\n\n\tlet STATES = {}\n\n\tlet cursor = { start: {}, end: {} }\n\tlet CURSOR = null\n\n\tconst SAY = m => console.log(`[App] ${m}`)\n\tconst w = window\n\n\tw.zoomEl = null\n\tw.canvasEl = null\n\tw.zoomTransform = {}\n\n\tw.DATA = []\n\tw.OUT = []\n\tw.FONTSIZE = 13\n\tw.HOVER = null\n\tw.HIGH = []\n\tw.ACTIVE = null\n\tw.width = 24\n\tw.height = 12\n\n\n\n\tw.KEYCODES = {}\n\n\n\tfunction createReference() {\n\t\treturn { date: new Date() }\n\t}\n\n\n\n\n\tfunction setSelected(layer) {\n\t\tconst { start, end } = layer\n\t\tconsole.log(`[App] set selected:`, start, end)\n\t\tif (layer) {\n\n\t\t\tw.ACTIVE = layer\n\n\t\t\tw.ACTIVE.origin = { ...cursor.start }\n\t\t\tw.ACTIVE.startOrigin = { ...layer.start }\n\t\t\tw.ACTIVE.endOrigin = { ...layer.end }\n\n\t\t}\n\n\t\tdraw()\n\t}\n\n\tlet IS_MOVING = false\n\tlet IS_RESIZING = false\n\n\tfunction onMouseover(y,x) {\n\t\t// w.HOVER = { y, x }\n\n\t}\n\n\tfunction onMousedown(y,x) {\n\n\t\tSTATES.pressed = true\n\t\tw.ACTIVE = false\n\n\t\tcursor.start = { y, x }\n\t\tcursor.end = { y, x }\n\n\t\tif ( $_mode == MODE_RECT ) {\n\t\t\tSAY(' create rect')\n\t\t\tSTATES[MODE_RECT] = true\n\t\t\tw.ACTIVE = {\n\t\t\t\ttype: MODE_RECT,\n\t\t\t\tref: createReference(),\n\t\t\t\tchars: [], // OUT\n\t\t\t\t...cursor,\n\t\t\t\ttext: LOREM.substring(0,10), // PRE\n\t\t\t\tfill: 17,\n\t\t\t\tcorner: 0,\n\t\t\t\tsides: 0,\n\t\t\t\tpadding: 2,\n\t\t\t\tinited: false,\n\t\t\t\talignX: ALIGN_START,\n\t\t\t\talignY: ALIGN_CENTER,\n\t\t\t}\n\t\t\tw.DATA = [ w.ACTIVE, ...w.DATA ]\n\t\t} else if ( $_mode == MODE_CHAR ) {\n\t\t\tSAY(' create chars')\n\t\t\tSTATES[MODE_CHAR] = true\n\t\t\tw.ACTIVE = {\n\t\t\t\ttype: MODE_CHAR,\n\t\t\t\tref: createReference(),\n\t\t\t\tchars: [], // OUT\n\t\t\t\t...cursor,\n\t\t\t\torigin: { ...cursor.start },\n\t\t\t\tinputs: {}, // PRE\n\t\t\t\tinited: false\n\t\t\t}\n\t\t\tw.DATA = [ w.ACTIVE, ...w.DATA ]\n\t\t} else if ( $_mode == MODE_SELECT ) {\n\t\t\tSAY(' create select')\n\t\t\tSTATES[MODE_SELECT] = true\n\t\t\tw.ACTIVE = {\n\t\t\t\ttype: MODE_SELECT,\n\t\t\t\tref: createReference(),\n\t\t\t\t...cursor,\n\t\t\t\tinited: false\n\t\t\t}\n\t\t\tdraw()\n\t\t} else if ($_mode == MODE_POINTER) {\n\t\t\tSAY(' create pointer')\n\t\t\tlet layer = getLayer(y,x)\n\t\t\tif (!layer) {\n\t\t\t\tw.HIGH = []\n\t\t\t\tdraw()\n\t\t\t\treturn SAY(' no item clicked')\n\t\t\t}\n\t\t\tif (y == layer.end.y && x == layer.end.x) {\n\t\t\t\tIS_RESIZING = true\n\t\t\t} else {\n\t\t\t\tIS_MOVING = true\n\t\t\t}\n\n\t\t\tconsole.log(`[App] selected layer:`, layer)\n\n\t\t\tw.ACTIVE = layer \n\t\t\tw.ACTIVE.origin = { ...cursor.start }\n\t\t\tw.ACTIVE.startOrigin = { ...w.ACTIVE.start }\n\t\t\tw.ACTIVE.endOrigin = { ...w.ACTIVE.end }\n\n\t\t\tsetRectChars()\n\t\t\tsetTextChars()\n\t\t\tdraw()\n\t\t}\n\t}\n\n\n\tlet lastMouseMove = {}\n\n\tfunction onMousemove(y,x) {\n\t\tif (!STATES.pressed) return // create dragging only\n\t\tif (lastMouseMove.x == x && lastMouseMove.y == y) return\n\n\t\t// set w.HIGH area\n\n\t\tlastMouseMove = cursor.end = { y, x }\n\n\t\tlet start = {...cursor.start}\n\t\tlet end = {...cursor.end}\n\n\t\t// flip start and end (drag backwards)\n\n\t\tif (cursor.start.x > cursor.end.x) {\n\t\t\tstart.x = cursor.end.x\n\t\t\tend.x = cursor.start.x\n\t\t}\n\n\t\tif (cursor.start.y > cursor.end.y) {\n\t\t\tstart.y = cursor.end.y\n\t\t\tend.y = cursor.start.y\n\t\t}\n\n\t\tif ( IS_MOVING && w.ACTIVE ) {\n\t\t\tconsole.log(`[App] drag move`)\n\t\t\tconst { origin, startOrigin, endOrigin, type } = w.ACTIVE\n\n\t\t\tw.ACTIVE.start.x = startOrigin.x + ( x - origin.x )\n\t\t\tw.ACTIVE.end.x = endOrigin.x + ( x - origin.x )\n\t\t\tw.ACTIVE.start.y = startOrigin.y + ( y - origin.y )\n\t\t\tw.ACTIVE.end.y = endOrigin.y + ( y - origin.y )\n\n\t\t\tw.HIGH = []\n\n\t\t\tdraw()\n\t\t}\n\n\t\t// resize\n\n\t\telse if ( IS_RESIZING && w.ACTIVE ) {\n\t\t\tconsole.log(`[App] drag resizing`)\n\t\t\tconst { origin, startOrigin, endOrigin, type } = w.ACTIVE\n\n\t\t\tw.ACTIVE.end.x = endOrigin.x + ( x - origin.x )\n\t\t\tw.ACTIVE.end.y = endOrigin.y + ( y - origin.y )\n\n\n\t\t\tw.HIGH = []\n\n\t\t\tdraw()\n\t\t}\n\t\t// rectangle\n\n\t\telse if (STATES[MODE_RECT]) {\n\t\t\tconsole.log(`[App] drag rectangle`)\n\t\t\tw.ACTIVE.start = start\n\t\t\tw.ACTIVE.end = end\n\n\t\t\tdraw()\n\t\t}\n\t\t// textbox\n\n\t\telse if (STATES[MODE_SELECT]) {\n\t\t\tconsole.log(`[App] drag select`)\n\t\t\tw.ACTIVE.start = start\n\t\t\tw.ACTIVE.end = end\n\t\t\tdraw()\n\t\t}\n\t\t// char\n\t\telse if (STATES[MODE_CHAR]) {\n\t\t\tconsole.log(`[App] drag chars`)\n\t\t\tw.ACTIVE.start = start\n\t\t\tw.ACTIVE.end = end\n\t\t\tdraw()\n\t\t}\n\n\n\t}  \n\n\tfunction onMouseup(y,x) {\n\t\tSTATES.pressed = false\n\n\n\t\tif (STATES[MODE_SELECT]) {\n\t\t\tSTATES[MODE_SELECT] = false\n\t\t\tw.ACTIVE.start = cursor.start\n\t\t\tw.ACTIVE.end = {y,x}\n\t\t}\n\t\tif (STATES[MODE_RECT]) STATES[MODE_RECT] = false\n\t\tif (STATES[MODE_CHAR]) STATES[MODE_CHAR] = false\n\n\t\tIS_RESIZING = false\n\t\tIS_MOVING = false\n\n\t\tif ( w.ACTIVE?.type == MODE_RECT) {\n\t\t\tif (w.ACTIVE.start.x == w.ACTIVE.end.x || w.ACTIVE.start.y == w.ACTIVE.end.y) {\n\t\t\t\tSAY(' deleting tiny rectangle')\n\t\t\t\tlet cp = w.DATA\n\t\t\t\tcp.shift()\n\t\t\t\tw.DATA = cp\n\n\n\t\t\t\tlet layer = getLayer(y,x)\n\t\t\t\tif (layer && $_mode == layer?.type) {\n\t\t\t\t\tconsole.log(`[App] selected with same tool type:`, layer)\n\t\t\t\t\tw.ACTIVE = layer \n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst { start, end } = w.DATA[0]\n\t\t\t\tSAY(' inited new rectangle:', start, end)\n\t\t\t\tw.DATA[0].inited = true\n\t\t\t}\n\t\t}\n\n\t\tdraw()\n\n\n\t}\n\n\tfunction setHighChars(y,x) {\n\t\tif (!w.ACTIVE) return\n\t\tif (w.ACTIVE.type == MODE_RECT || w.ACTIVE.type == MODE_SELECT) {\n\t\t\treturn (x >= w.ACTIVE.start.x && x <= w.ACTIVE.end.x) && (y >= w.ACTIVE.start.y && y <= w.ACTIVE.end.y)\n\t\t}\n\t}\n\n\tlet lastWidth, lastHeight\n\t$: ((w,h) => {\n\t\tif (w != lastWidth || h != lastHeight) {\n\t\t\tdraw()\n\t\t\tlastWidth = w\n\t\t\tlastHeight = h\n\t\t}\n\t})(w.width,w.height)\n\n\tfunction awaitDraw() {\n\t\tw.requestAnimationFrame( draw )\n\t}\n\n\t// w.DB = null\n\tw.DB_TIMEOUT = null\n\n\tfunction draw() {\n\n\t\tSAY(`🌱 drawn`)\n\t\tsetRectChars()\n\t\tsetTextChars()\n\t\tsetCharChars()\n\n\t\tw.HIGH = []\n\n\t\tconst { start, end } = w.ACTIVE || {}\n\t\tconst isBlock = (w.ACTIVE) ? w.ACTIVE.type == MODE_RECT || w.ACTIVE.type == MODE_SELECT : false\n\n\t\t// const spans = document.getElementById('canvas')?.querySelectorAll('span') || []\n\n\t\tlet i = 0\n\t\tfor (let y = 0; y < w.height; y++) {\n\t\t\tfor (let x = 0; x < w.width; x++) {\n\n\t\t\t\tif (!w.OUT[y]) w.OUT[y] = []\n\t\t\t\tconst char = getChar(y,x)\n\t\t\t\tif (w.OUT[y][x] != char || w.OUT[y][x] == undefined ) w.OUT[y][x] = char\n\n\t\t\t\t// if (spans[i]) spans[i].innerText = w.OUT[y][x] || SPACE\n\n\t\t\t\tconst withinX = (x >= start?.x && x <= end?.x)\n\t\t\t\tconst withinY = (y >= start?.y && y <= end?.y)\n\t\t\t\tif (!w.HIGH[y]) w.HIGH[y] = []\n\t\t\t\tw.HIGH[y][x] = (withinX && withinY)\n\n\t\t\t\ti += 1\n\t\t\t}\n\t\t}\n\n\t\tif (w.DB_TIMEOUT) clearTimeout(w.DB_TIMEOUT)\n\t\tw.DB_TIMEOUT = setTimeout( e => {\n\t\t\tw.localStorage.setItem('DB', JSON.stringify(w.DATA))\n\t\t\tSAY(`💾 saved`)\n\t\t}, 1000)\n\n\t}\n\n\tonMount( async e => {\n\t\ttry {\n\t\t\tw.DATA = JSON.parse(w.localStorage.getItem('DB'))\n\t\t\tawait awaitDraw()\n\t\t\tSAY(`💾 loaded`)\n\t\t} catch(err) {\n\t\t\tconsole.warn(`💾 nothing loaded`)\n\t\t}\n\n\n        w.zoomer = panzoom( w.zoomEl, {\n            maxZoom: 20,\n            minZoom: 0.02,\n            zoomDoubleClickSpeed: 1,\n            filterKey: e => true,\n            beforeMouseDown: e => {\n            \treturn e.target.classList.contains('char')\n            }\n        })\n\n        w.zoomer.on('transform', e => {\n            w.zoomTransform = w.zoomer.getTransform()\n        })\n        w.zoomer.on('pan', e => {\n        \tw.isPanning = true\n        })\n        w.zoomer.on('panend', e => {\n        \tw.isPanning = false\n        })\n\t})\n\n\n\tfunction getChar( y, x ) {\n\t\tfor (let layer of w.DATA) if ( layer?.chars?.[y]?.[x] ) return layer.chars[y][x]\n\t\treturn null\n\t}\n\tfunction getLayer( y, x ) {\n\t\tfor (let layer of w.DATA) if ( layer?.chars?.[y]?.[x] ) return layer\n\t\treturn null\n\t}\n\n\n\n\t$: fontStyle = `\n\t\tfont-size: ${w.FONTSIZE}px;\n\t\tline-height: 1em;\n\t\twidth: ${Math.round(w.FONTSIZE * 0.6)}px;\n\t\tmax-width: ${Math.round(w.FONTSIZE * 0.6)}px;\n\t\tmin-width: ${Math.round(w.FONTSIZE * 0.6)}px;\n\t`\n\t$: outlineStyle = !w.ACTIVE ? '' : `\n\t\ttransform: \n\t\ttranslate(${w.ACTIVE?.start?.x*8}px, ${w.ACTIVE?.start?.y}em);\n\t\twidth: ${(w.ACTIVE?.end?.x-w.ACTIVE?.start?.x)*8}px;\n\t\theight: ${w.ACTIVE?.end?.y-w.ACTIVE?.start?.y}em;\n\t`\n\n\tlet metaKeys = []\n\n\tconst onKeydownPre = e => {\n\t\t// SAY(' keydown ', e.code)\n\t\t$_keys[e.code] = true\n\t\tif (e.metaKey) metaKeys.push(e.code)\n\t\tonKeydown( e )\n\t\tdraw()\n\t}\n\tconst onKeyupPre = e => {\n\t\t// SAY(' keyup ', e.code)\n\t\t$_keys[e.code] = false\n\t\tif (metaKeys.length > 0) {\n\t\t\tfor (const key of metaKeys) $_keys[key] = false\n\t\t\tmetaKeys = []\n\t\t}\n\t\tonKeyup( e )\n\t\tdraw()\n\t}\n\n\tfunction deselectAll() {\n\t\tconsole.log('?')\n\t\tw.ACTIVE = null\n\t\tw.HIGH = []\n\t\tdraw()\n\t}\n\n\tfunction onTextboxKeydownPre(e) {\n\t\tonTextboxKeydown(e)\n\t\tawaitDraw()\n\t}\n\n\tw.mousecursor = ''\n\tw.isPanning = false\n\n\tfunction onWindowMousemove(e ) {\n\t\tconst {classList} = e.target\n\t\tif (w.isPanning) return\n\t\tif (classList.contains('active')) {\n\t\t\tw.mousecursor = 'pointer'\n\t\t} else if (classList.contains('dragger')) {\n\t\t\tw.mousecursor = ''\n\t\t} else {\n\t\t\tw.mousecursor = ''\n\t\t}\n\t} \n\n\n</script>\n<svelte:window \n\ton:keydown={ onKeydownPre }\n\ton:keyup={ onKeyupPre }\n\ton:mousemove={ onWindowMousemove }\n\ton:mouseup={ e => STATES.pressed = false } />\n<input type=\"text\" id=\"capture\" class=\"invisible hidden fixed\" />\n<main class=\"sassis sink fill monospace overflow-hidden b10-solid {w.mousecursor}\">\n\n\t\t<div \n\t\t\ton:mousedown={ deselectAll }\n\t\t\tclass=\"dragger fill\" />\n\n\t\t<div \n\t\t\tbind:this={w.zoomEl}\n\t\t\tid=\"zoom\"\n\t\t\tclass=\"fill flex column-center-center\">\n\t\t\t<div \n\t\t\t\tbind:this={w.canvasEl}\n\t\t\t\tid=\"canvas\"\n\t\t\t\tclass=\"flex column-center-flex-start rel monospace user-select-none bg overflow-auto pop\">\n\t\t\t\t{#each w.OUT as line, y}\n\t\t\t\t\t<div class=\"no-grow\">\n\t\t\t\t\t\t{#each line as char, x}\n\t\t\t\t\t\t\t<span\n\t\t\t\t\t\t\t\tclass:active={char}\n\t\t\t\t\t\t\t\tclass:inactive={!char}\n\t\t\t\t\t\t\t\tstyle={fontStyle}\n\t\t\t\t\t\t\t\tclass:b1-solid={w.HOVER?.y == y && w.HOVER?.x == x }\n\t\t\t\t\t\t\t\tclass=\"char rel\"\n\t\t\t\t\t\t\t\tclass:filled={ w.HIGH?.[y]?.[x] }\n\t\t\t\t\t\t\t\ton:mousemove={e => onMousemove(y,x)}\n\t\t\t\t\t\t\t\ton:mouseup={e => onMouseup(y,x)}\n\t\t\t\t\t\t\t\ton:mousedown={e => onMousedown(y,x)}\n\t\t\t\t\t\t\t\ton:mouseover={e => onMouseover(y,x)}>\n\t\t\t\t\t\t\t\t{@html char || SPACE}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</div>\n\t\t\t\t{/each}\n\t\t\t</div>\n\n\t\t</div>\n\n\n\n\n\n\n\n\t\t<Panel title=\"Properties\" right={20} top={100}>\n\n\t\t\t<div class=\"flex column-stretch-flex-start p0-5\">\n\t\t\t\t{#if w.ACTIVE}\n\n\t\t\t\t\t{#if w.ACTIVE.type == MODE_RECT}\n\t\t\t\t\t\t<label>fill</label>\n\t\t\t\t\t\t<input \n\t\t\t\t\t\t\ton:change={awaitDraw}\n\t\t\t\t\t\t\ttype=\"number\" \n\t\t\t\t\t\t\tbind:value={w.ACTIVE.fill} />\n\t\t\t\t\t\t<label>corner</label>\n\t\t\t\t\t\t<input \n\t\t\t\t\t\t\ton:change={awaitDraw}\n\t\t\t\t\t\t\ttype=\"number\" \n\t\t\t\t\t\t\tbind:value={w.ACTIVE.corner} />\n\t\t\t\t\t\t<label>sides</label>\n\t\t\t\t\t\t<input \n\t\t\t\t\t\t\ton:change={awaitDraw}\n\t\t\t\t\t\t\ttype=\"number\" \n\t\t\t\t\t\t\tbind:value={w.ACTIVE.sides} />\n\t\t\t\t\t\t<label>x</label>\n\t\t\t\t\t\t<select \n\t\t\t\t\t\t\ton:change={awaitDraw}\n\t\t\t\t\t\t\tbind:value={w.ACTIVE.alignX}>\n\t\t\t\t\t\t\t{#each [ALIGN_START,ALIGN_CENTER,ALIGN_END, ALIGN_JUSTIFY] as opt}\n\t\t\t\t\t\t\t\t<option value={opt}>{opt}</option>\n\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t</select>\n\t\t\t\t\t\t<label>y</label>\n\t\t\t\t\t\t<select \n\t\t\t\t\t\t\ton:change={awaitDraw}\n\t\t\t\t\t\t\tbind:value={w.ACTIVE.alignY}>\n\t\t\t\t\t\t\t{#each [ALIGN_START,ALIGN_CENTER,ALIGN_END] as opt}\n\t\t\t\t\t\t\t\t<option value={opt}>{opt}</option>\n\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t</select>\n\t\t\t\t\t\t<label class=\"checkbox\">\n\t\t\t\t\t\t\t<input \n\t\t\t\t\t\t\t\ton:change={awaitDraw}\n\t\t\t\t\t\t\t\ttype=\"checkbox\" \n\t\t\t\t\t\t\t\tbind:checked={w.ACTIVE.whitespace} />\n\t\t\t\t\t\t\twhitespace\n\t\t\t\t\t\t\t<span />\n\t\t\t\t\t\t</label>\n\t\t\t\t\t{/if}\n\t\t\t\t{:else}\n\n\t\t\t\t\t<span>fontsize</span>\n\t\t\t\t\t<input \n\t\t\t\t\t\ttype=\"number\" \n\t\t\t\t\t\tbind:value={w.FONTSIZE} />\n\t\t\t\t\t<span>width</span>\n\t\t\t\t\t<input \n\t\t\t\t\t\ttype=\"number\" \n\t\t\t\t\t\tbind:value={w.width} />\n\n\t\t\t\t\t<span>height</span>\n\t\t\t\t\t<input \n\t\t\t\t\t\ttype=\"number\" \n\t\t\t\t\t\tbind:value={w.height} />\n\t\t\t\t{/if}\n\t\t\t</div>\n\t\t</Panel>\n\n\t\t<Panel title=\"Tools\" left={20} top={50}>\n\n\t\t\t<nav id=\"toolbar\" class=\"column flex\">\n\t\t\t\t{#each Object.keys(MODES) as tool, idx}\n\t\t\t\t\t<div\n\t\t\t\t\t\ton:mousedown={ e => ($_mode = tool)}\n\t\t\t\t\t\tclass:filled={$_mode == tool}\n\t\t\t\t\t\tclass=\"bb p0-5 text-left\">\n\t\t\t\t\t\t[{idx+1}] {tool}\n\t\t\t\t\t</div>\n\t\t\t\t{/each}\n\t\t\t</nav>\n\t\t</Panel>\n\n\t\t<Panel title=\"Input\" left={20} bottom={20}>\n\t\t\t<Keyboard />\n\t\t</Panel>\n\n\t\t<Panel title=\"Layers\" right={20} top={50}>\n\t\t\t<div id=\"layers\" class=\"flex overflow-auto column grow\">\n\t\t\t\t{#each w.DATA as layer, idx}\n\t\t\t\t\t{#if layer.inited}\n\t\t\t\t\t\t<div \n\t\t\t\t\t\t\ton:click={e => setSelected(layer)}\n\t\t\t\t\t\t\tclass=\"bb1-solid w100pc flex column\">\n\t\t\t\t\t\t\t<header \n\t\t\t\t\t\t\t\tclass:filled={ layer?.ref == w.ACTIVE?.ref }\n\t\t\t\t\t\t\t\tclass=\"pointer p0-5 w100pc flex row-space-between-center\">\n\t\t\t\t\t\t\t\t<div>{layer.type}</div>\n\t\t\t\t\t\t\t\t<!-- <div class=\"flex row-stretch-stretch h100pc cp0-5  cbl1-solid\">\n\t\t\t\t\t\t\t\t\t<div class=\"\">S</div>\n\t\t\t\t\t\t\t\t\t<div class=\"\">M</div>\n\t\t\t\t\t\t\t\t</div> -->\n\t\t\t\t\t\t\t</header>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/if}\n\t\t\t\t{/each}\n\t\t\t\t{#if w.DATA.length == 0}\n\n\t\t\t\t\t<div class=\"grow w100pc flex row-center-center italic p0-5 fade\">\n\t\t\t\t\t\tno layers\n\t\t\t\t\t</div>\n\t\t\t\t{/if}\n\t\t\t</div>\n\t\t</Panel>\n\n\n\t\t\t<Panel title=\"Text\" right={20} bottom={20}>\n\t\t\t\t<div class=\"minh16em minw24em grow flex column\">\n\t\t\t\t\t{#if w.ACTIVE?.type == MODE_RECT}\n\t\t\t\t\t\t<textarea\n\t\t\t\t\t\t\ton:keyup={onTextboxKeyup}\n\t\t\t\t\t\t\ton:keydown={onTextboxKeydownPre}\n\t\t\t\t\t\t\tclass=\"flex grow w100pc h100pc grow b0-solid\"\n\t\t\t\t\t\t\trows=\"4\"\n\t\t\t\t\t\t\tbind:value={w.ACTIVE.text} />\n\t\t\t\t\t{:else}\n\t\t\t\t\t\t<div class=\"grow w100pc flex row-center-center italic p0-5 fade\">\n\t\t\t\t\t\t\tnothing selected\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/if}\n\t\t\t\t</div>\n\t\t\t</Panel>\n</main>","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {\n\t}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","subscribe","store","callbacks","unsub","unsubscribe","get_store_value","value","_","component_subscribe","component","callback","$$","on_destroy","push","get_slot_context","definition","ctx","$$scope","tar","src","k","assign","slice","set_store_value","ret","set","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","destroy_each","iterations","detaching","i","length","d","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","to_number","set_data","wholeText","set_input_value","input","set_style","key","important","style","setProperty","select_option","select","option","__value","selected","selectedIndex","select_value","selected_option","querySelector","toggle_class","toggle","classList","current_component","set_current_component","onMount","Error","get_current_component","on_mount","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","flushing","seen_callbacks","Set","flush","update","pop","has","add","clear","fragment","before_update","dirty","p","after_update","outroing","transition_in","block","local","delete","transition_out","o","outros","c","globals","window","globalThis","global","create_component","mount_component","customElement","m","new_on_destroy","map","filter","destroy_component","make_dirty","then","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","Map","skip_bound","root","ready","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","$destroy","this","$on","type","index","indexOf","splice","$set","$$props","obj","$$set","keys","addWheelListener","listener","useCapture","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","LinearEasing","x","mX1","mY1","mX2","mY2","sampleValues","getTForX","aX","intervalStart","currentSample","kSplineTableSize","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","binarySubdivide","animations","ease","BezierEasing","easeIn","easeOut","easeInOut","linear","source","start","diff","easing","console","warn","step","done","scheduler","requestAnimationFrame","next","bind","cancel","cancelAnimationFrame","cb","setTimeout","id","clearTimeout","getScheduler","previousAnimationId","durationInMs","duration","durationInFrames","max","frame","loop","t","setValues","makeAggregateRaf","frontBuffer","backBuffer","frameToken","clearAll","renderFrame","subject","reservedWords","hasOwnProperty","validateSubject","eventsStorage","registeredEvents","on","eventName","handlers","off","fire","fireArguments","arguments","prototype","call","callbackInfo","apply","createEventsStorage","getPoint","scroll","settings","lastPoint","timestamp","ticker","vx","targetX","ax","vy","targetY","ay","raf","minVelocity","amplitude","getCancelAnimationFrame","getRequestAnimationFrame","Date","track","stop","currentPoint","y","now","autoScroll","elapsed","dx","dy","dt","moving","exp","useFake","capture","release","dragObject","prevSelectStart","prevDragStart","wasCaptured","domObject","onselectstart","ondragstart","disabled","e","stopPropagation","scale","svgElement","isSVGElement","owner","ownerSVGElement","disableKeyboardInteraction","getBBox","bbox","left","top","width","height","getScreenCTM","ctm","getCTM","getOwner","applyTransform","transform","initTransform","screenCTM","createElementNS","createSVGMatrix","f","removeAttributeNS","domElement","isDomElement","parentElement","scrollTop","clientWidth","clientHeight","transformOrigin","domTextSelectionInterceptor","createTextSelectionInterceptor","fakeTextSelectorInterceptor","createPanZoom","panController","controller","makeSvgController","canAttach","makeDomController","storedCTMResult","isDirty","Transform","frameAnimation","filterKey","pinchSpeed","bounds","maxZoom","Number","POSITIVE_INFINITY","minZoom","boundsPadding","zoomDoubleClickSpeed","beforeWheel","beforeMouseDown","speed","zoomSpeed","parseTransformOrigin","textSelection","enableTextSelection","boundsType","isNumber","bottom","right","validateBounds","autocenter","w","h","sceneBoundingBox","getBoundingBox","ownerRect","getBoundingClientRect","dh","dw","min","lastSingleFingerOffset","mouseX","mouseY","pinchZoomLength","smoothScroll","moveByAnimation","zoomToAnimation","multiTouch","lastTouchEndTime","touchInProgress","panstartFired","kinetic","cancelZoomAnimation","moveTo","paused","listenForEvents","api","dispose","releaseEvents","moveBy","internalMoveBy","smoothMoveTo","centerOn","ui","parent","clientRect","cx","cy","container","zoomTo","publicZoomTo","zoomAbs","smoothZoom","smoothZoomAbs","clientX","clientY","toScaleValue","to","animate","v","showRectangle","rect","size","transformToScreen","rectWidth","rectHeight","isFinite","pause","resume","isPaused","getTransform","getMinZoom","setMinZoom","newMinZoom","getMaxZoom","setMaxZoom","newMaxZoom","getTransformOrigin","setTransformOrigin","newTransformOrigin","getZoomSpeed","setZoomSpeed","newSpeed","eventify","initialX","initialY","initialZoom","parentCTM","parentScaleX","parentScaleY","parentOffsetX","parentOffsetY","keepTransformInsideBounds","triggerEvent","makeDirty","boundingBox","leftTop","adjusted","sceneWidth","sceneHeight","zoomByRatio","ratio","isNaN","newScale","zoomLevel","smooth","lastX","lastY","onMouseDown","passive","onDoubleClick","onTouch","onKeyDown","wheel","onMouseWheel","removeWheelListener","releaseDocumentMouse","releaseTouches","triggerPanEnd","z","keyCode","preventDefault","offset","scaleMultiplier","getScaleMultiplier","getTransformOriginOffset","beforeTouch","touches","getOffsetXY","point","startTouchListenerIfNeeded","handleSingleFingerTouch","getPinchZoomLength","handleTouchMove","handleTouchEnd","triggerPanStart","t1","t2","currentPinchLength","firstTouchPoint","secondTouchPoint","finger1","finger2","sqrt","beforeDoubleClick","button","onMouseMove","onMouseUp","srcElement","delta","deltaY","deltaMode","fromValue","triggerZoomEnd","sign","failTransformOrigin","error","join","scripts","getElementsByTagName","panzoomScript","match","query","globalName","started","tryAttach","el","script","attrs","attributes","j","nameValue","getPanzoomAttributeNameValue","collectOptions","log","substr","JSON","parse","autoRun","slot_ctx","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","lets","undefined","merged","len","title","minimised","SAY","grabbing","og","localStorage","getItem","err","timeout","replaceAll","setItem","stringify","zoomer","MODE_RECT","MODE_POINTER","MODE_SELECT","MODE_CHAR","SPACE","ALIGN_START","ALIGN_CENTER","ALIGN_END","ALIGN_JUSTIFY","INPUT_ELEMENTS","MODES","INPUT_KEYS","SQUARE_CORNERS","tl","tr","bl","br","LINES","BLOCKS","KEYS","KEYS_ICONS","BOARDS","BOARD_NAMES","setRectChars","ACTIVE","end","chars","topBottom","leftRight","withinX","withinY","sel","_BLOCK","corner","sides","HIGH","setTextChars","padding","whitespace","bC","bS","alignX","alignY","blockWidth","blockHeight","lines","currentLine","paragraph","split","word","yDiff","aYCenter","aXCenter","aYEnd","aXEnd","yy","xx","round","line","xDiff","char","subscriber_queue","writable","subscribers","new_value","run_queue","subscriber","invalidate","_keys","_keyboardIdx","_showKeyboard","_activeElement","_mode","Diff","buildValues","components","newString","oldString","useLongestToken","componentPos","componentLen","newPos","oldPos","removed","count","added","tmp","oldValue","lastComponent","equals","clonePath","path","self","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","bestPath","extractCommon","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","pushComponent","exec","last","commonCount","comparator","ignoreCase","toLowerCase","array","extendedWordChars","reWhitespace","wordDiff","ignoreWhitespace","test","tokens","lineDiff","_typeof","Symbol","iterator","constructor","retLines","linesAndNewlines","newlineIsToken","trim","objectPrototypeToString","toString","jsonDiff","canonicalize","stack","replacementStack","replacer","canonicalizedObj","toJSON","_key","sortedKeys","sort","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","replace","arrayDiff","navigator","keyboard","getLayoutMap","keyboardLayoutMap","getElementById","dispatchEvent","Event","KeyboardEvent","code","values","ARROWKEYS","getStores","keyboardIdx","get","board","mode","modes","activeElement","number","keyboardWasTabbed","async","onTextboxKeydown","metaKey","ctrlKey","selectionStart","selectionEnd","substring","setSelectionRange","onTextboxKeyup","onKeyup","onKeydown","blur","_CLIP","OUT","clipboard","alert","writeText","_UNIT","MODE","inputs","cp","DATA","idx","find","ref","setActiveElement","$_activeElement","$_showKeyboard","onSetIndex","$_keyboardIdx","currentlyPressed","onKeyMousedown","ii","kys","curp","show","kidx","HOVER","FONTSIZE","inited","mousecursor","createReference","date","STATES","cursor","setSelected","layer","origin","startOrigin","endOrigin","draw","zoomEl","canvasEl","zoomTransform","KEYCODES","IS_MOVING","IS_RESIZING","onMousedown","pressed","$_mode","getLayer","lastWidth","lastHeight","lastMouseMove","onMousemove","onMouseup","shift","awaitDraw","setCharChars","getChar","DB_TIMEOUT","panzoom","contains","isPanning","metaKeys","fontStyle","$_keys","tool","body"],"mappings":"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"}